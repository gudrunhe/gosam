module     four_gluon
   !
   ! Implementation of the results in [1] (s. README)
   !
   implicit none
   private

   double precision, parameter :: TR = 0.5d0
   double precision, parameter :: NC = 3.0d0
   double precision, parameter :: NA = NC*NC - 1.0d0
   double precision, parameter :: CA = NC
   double precision, parameter :: CCO = (2.0d0*TR**4*NA)*NC**2 * 12.0d0
   double precision, parameter :: CDD = (2.0d0*TR**4*NA)*NC**2 * NC**2
   double precision, parameter :: pi = 3.14159265358979323846264338327948d0

   public :: amp_ppmm
contains

   pure subroutine amp_ppmm(s, t, u, scale2, res0, res1)
      implicit none
      double precision, intent(in) :: s, t, u, scale2
      double precision, intent(out) :: res0
      double precision, intent(out), dimension(0:2) :: res1

      ! temporaries introduced by haggies[% 
   @for symbols registers="tmp%d" %]
      [% type.repr %] :: [% $_ %][%
   @end @for %]
      ! temporaries introduced by Form's ToPolynomial[%
   @for instructions registers="tmp%d" %][%
      @select $_ match="(.).*" format="%s"
      @case Z %]
      double complex :: [% $_ %][%
      @end @select %][%
   @end @for %]

      ! instructions generated by haggies[%
   @for instructions registers="tmp%d" %][%
      @select $_
      @case res1_0 %]
      res1(0) = [% expression %][%
      @case res1_1 %]
      res1(1) = [% expression %][%
      @case res1_2 %]
      res1(2) = [% expression %][%
      @else %]
      [% $_ %] = [% expression %][%
      @end @select %][%
   @end @for %]
   end  subroutine amp_ppmm

   pure function zlog(s, deltas, t, deltat)
      implicit none
      double precision, intent(in) :: s, t, deltas, deltat
      double complex :: zlog

      double complex :: lg
      double precision :: st, dst

      st = s/t
      dst = sign(1.0d0,deltas*t-deltat*s)

      if(st > 0.0d0) then
         zlog = dcmplx(log(st), 0.0d0)
      else
         zlog = dcmplx(log(-st), dst * pi)
      end if
   end  function zlog

end module four_gluon
