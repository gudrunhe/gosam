module     four_gluon
   !
   ! Implementation of the results in [1] (s. README)
   !
   implicit none
   private

   double precision, parameter :: TR = 0.5d0
   double precision, parameter :: NC = 3.0d0
   double precision, parameter :: NA = NC*NC - 1.0d0
   double precision, parameter :: CA = NC
   double precision, parameter :: CCO = (2.0d0*TR**4*NA)*NC**2 * 12.0d0
   double precision, parameter :: CDD = (2.0d0*TR**4*NA)*NC**2 * NC**2
   double precision, parameter :: pi = 3.14159265358979323846264338327948d0

   public :: amp_ppmm
contains

   pure subroutine amp_ppmm(s, t, u, scale2, res0, res1)
      implicit none
      double precision, intent(in) :: s, t, u, scale2
      double precision, intent(out) :: res0
      double precision, intent(out), dimension(0:2) :: res1

      ! temporaries introduced by haggies
      double precision :: tmp1
      double precision :: tmp2
      double precision :: tmp3
      double precision :: tmp4
      double precision :: tmp5
      double complex :: tmp6
      double complex :: tmp7
      double complex :: tmp8
      double complex :: tmp9
      double complex :: tmp10
      double complex :: tmp11
      double complex :: tmp12
      double complex :: tmp13
      ! temporaries introduced by Form's ToPolynomial
      double complex :: Z1_
      double complex :: Z2_
      double complex :: Z3_
      double complex :: Z4_
      double complex :: Z5_
      double complex :: Z6_
      double complex :: Z7_
      double complex :: Z8_
      double complex :: Z9_

      ! instructions generated by haggies
      tmp1 = s*s
      tmp2 = t*u
      Z1_ = (tmp1/(tmp2*tmp2))
      Z2_ = 1.0d0/NC
      Z3_ = 1.0d0/s
      Z4_ = (zlog(-(u),-1.0d0,scale2,0.0d0))
      Z5_ = (zlog(-(t),-1.0d0,scale2,0.0d0))
      Z6_ = (zlog(-(s),-1.0d0,scale2,0.0d0))
      Z7_ = (zlog(s,1.0d0,t,1.0d0))
      Z8_ = (zlog(s,1.0d0,u,1.0d0))
      Z9_ = (zlog(u,1.0d0,t,1.0d0))
      tmp2 = t*t
      tmp3 = u*u
      res0 = (16.0d0*(tmp1+tmp2+tmp3)*CDD*Z1_*Z2_*Z2_)
      tmp6 = Z6_*Z6_
      tmp7 = Z3_*u
      tmp8 = 4.0d0*tmp7*tmp7
      tmp9 = Z9_*Z9_
      tmp4 = pi*pi
      tmp10 = tmp4+tmp9
      tmp11 = 2.0d0*tmp10*tmp3
      tmp12 = tmp11+tmp10*tmp2
      tmp7 = 4.0d0+4.0d0*tmp7
      tmp5 = tmp3*tmp3
      tmp13 = tmp10*u
      res1(0) = (((((352.0d0/3.0d0-176.0d0/3.0d0*Z5_)*s+(16.0d0*(Z7_*Z7_-tmp6)&
      &+(8.0d0+tmp8)*tmp9+(24.0d0+tmp8)*tmp4+(176.0d0/3.0d0-16.0d0*Z5_)*Z5_-10&
      &72.0d0/9.0d0)*u)*u+(16.0d0*(-(Z5_*Z5_+Z4_*Z4_))+4.0d0*tmp10-16.0d0/9.0d&
      &0)*tmp1+((352.0d0/3.0d0-176.0d0/3.0d0*Z4_)*s+(8.0d0*(3.0d0*tmp4+tmp9)+1&
      &6.0d0*(Z8_*Z8_-tmp6)+(176.0d0/3.0d0-16.0d0*Z4_)*Z4_+4.0d0*(4.0d0*(Z4_-Z&
      &5_)*u+tmp12*Z3_)*Z3_-1072.0d0/9.0d0)*t-16.0d0*(1.0d0-(Z5_-Z4_)*Z3_*u)*u&
      &)*t)*CDD+(4.0d0*((tmp12+((tmp11+(tmp13+tmp10*t)*t)*t+2.0d0*tmp13*tmp3)*&
      &Z3_)*t+tmp10*tmp5*Z3_)*t+(tmp4*tmp7+tmp7*tmp9)*tmp5)*CCO*Z3_*Z3_)*Z1_*Z&
      &2_)
      tmp4 = 176.0d0/3.0d0*s
      res1(1) = (((tmp4+(32.0d0*(Z4_+Z6_)-176.0d0/3.0d0)*t)*t+(tmp4+(32.0d0*(Z&
      &5_+Z6_)-176.0d0/3.0d0)*u)*u+32.0d0*(Z4_+Z5_)*tmp1)*CDD*Z1_*Z2_)
      res1(2) = (64.0d0*(-(tmp3+tmp2+tmp1))*CDD*Z1_*Z2_)
   end  subroutine amp_ppmm

   pure function zlog(s, deltas, t, deltat)
      implicit none
      double precision, intent(in) :: s, t, deltas, deltat
      double complex :: zlog

      double complex :: lg
      double precision :: st, dst

      st = s/t
      dst = sign(1.0d0,deltas*t-deltat*s)

      if(st > 0.0d0) then
         zlog = dcmplx(log(st), 0.0d0)
      else
         zlog = dcmplx(log(-st), dst * pi)
      end if
   end  function zlog

end module four_gluon
