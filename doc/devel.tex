\documentclass[11pt,a4paper]{refrep}
\usepackage{xspace}
\usepackage[final]{remark}
\usepackage{listings}
\usepackage{amsmath,amssymb}
\usepackage{syntax}
\usepackage{color}
\usepackage[pdftex]{hyperref}
\usepackage{longtable}
\usepackage{multirow}

\input lstform
\input lstolp
\input lstgosam
\newcommand{\golemversion}{{1{.}0}}
\newcommand{\golem}{{\tt GoSam}\xspace}
%\newcommand{\golemv}[1][\golemversion]{{{\tt Golem}~\golemversion}\xspace}
\newcommand{\golemv}[1][\golemversion]{{\tt GoSam}\xspace}
\newcommand{\golemVC}{{\tt golem95}\xspace}
\newcommand{\packagename}{{gosam-\golemversion}}
\newcommand{\hepforge}{{\sc HepForge}\xspace}

\newcommand{\qgraf}{{\tt QGraf}\xspace}
\newcommand{\form}{{\tt Form}\xspace}
\newcommand{\python}{{\tt Python}\xspace}
\newcommand{\fortranXC}{{\tt Fortran\,95}\xspace}
\newcommand{\fortranMMIII}{{\tt Fortran\,2003}\xspace}
\newcommand{\pjfry}{{\tt PJFry}\xspace}
\newcommand{\haggies}{{\tt haggies}\xspace}
\newcommand{\samurai}{{\sc Samurai}\xspace}

\newcommand{\contl}{{\ensuremath{\hookrightarrow}}}
\newcommand{\fmslash}[1]{{#1}\!\!\!/}
\newcommand{\pslash}[1][{}]{\ensuremath{\fmslash{p}_{#1}}}
\newcommand{\kslash}[1][{}]{\ensuremath{\fmslash{k}_{#1}}}

\title{\golemv Developer's Manual}
\author{Thomas Reiter}
\date{Version \today}

\lstset{basicstyle=\tt,keywordstyle=\tt\color{blue}}

\begin{document}
\hypersetup{%
	pdfborder={0 0 0},%
	pdftitle={GoSam \golemversion{} Developer's Manual},%
	pdfauthor={Thomas Reiter},%
	pdfsubject={High Energy Physics/Higher Order Corrections},%
	pdfkeywords={NLO, automatization},%
	pdfdisplaydoctitle
}

\begin{fullpage}
\maketitle
\tableofcontents
\end{fullpage}

\chapter{Introduction}
\section{Overview}
The \golem{} source code can be divided in three main parts:
\begin{itemize}
\item A \python{} program controlling the first step of the code generation,
\item \form{} code, most of which is part of the templates
\item \fortranXC{} code, which is completely generated by templates.
\end{itemize}
Moreover there are few percent of the code not covered by the above list:
\begin{itemize}
\item The file \texttt{process.hh} is produced directly by the \python{}
   code, there is no template for it.
\item \haggies{} is written in Java. It is only included as a JAR file
   in the \texttt{haggies} subdirectory. The source code is not part of
   \golem{}.
\item The hand-written model files in the directory \texttt{models}
   contain \qgraf{} model files.
\item The subdirectory \texttt{olp/templates} contains files written
   in \texttt{C}, \texttt{Lex} and \texttt{Yacc}.
\item The \form{} files for the Lorentz representations (propagators and
   wave functions) are written in the Literate Programming system
   \texttt{nuweb}.
\end{itemize}

Most of the time a developer will only need to modify the files in the
template directory. Therefore this part of the code is discussed first.

\chapter{The Template System}
\section{Introduction}
\golem{} introduces a template processor (sophisticated preprocessor)
to create another level of abstraction between the \python{} code and
the generated code. The advantages of such a system are:
\begin{itemize}
\item There is no need to know \python{} in order to apply simple
   modifications and extensions to the program.
\item The template language is side effect free reducing the risk
   of hidden bugs.
\item The templates allow one to think in terms of the target language
   and reduce the need of escaping syntactical entities.
\end{itemize}
Unfortunately, there is no light without shadows:
\begin{itemize}
\item The developer needs to learn another language, i.e. the
   template markup language.
\item The simplicity of the markup language sometimes requires
   to express things in a complicated way.
\end{itemize}

\section{The File \texttt{template.xml}}
The template processor is written in \python{} and is controlled
by a XML file, by default this is the file \texttt{templates/template.xml}
in the \golem{} installation directory.
\attention The variable \texttt{templates} in the process input file
can either be set to a XML file or to a directory which contains
a file called \marginlabel{\texttt{template.xml}}\texttt{template.xml}.
If the variable is set, that
file is used instead of \golem{}'s \texttt{templates/template.xml}.
This feature could be used to provide template directories for specific
purposes.

\subsection{The \texttt{<template>} Tag}
The \texttt{<template>} tag is the root element of the template file.
All other tags must be nested elements of this tag.

\paragraph{Attributes}
\begin{description}
\item[\texttt{name}] (mandatory) a human-readable name for this template
\item[\texttt{version}] (mandatory) a version number
\item[\texttt{author}] (mandatory) one or multiple author names
\item[\texttt{author-email}] (mandatory) the email address of one of the
    authors
\item[\texttt{description}] (mandatory) a longer informal description of
    this template, e.g. in how far it differs from the defaul templates
    etc.
\end{description}

\paragraph{Nested Tags}
\begin{itemize}
\item \texttt{<file>} tags, describing how a template file is translated
   to a destination file,
\item \texttt{<directory>} tags, indicating that a file is read from or
   written to a subdirectory. This tag can have nested
   \texttt{<directory>}, \texttt{<file>} or \texttt{<foreach>} tags.
\item \texttt{<foreach iterator="name">} tags, where \texttt{name} is
   either \texttt{helicity}, \texttt{crossings} or \texttt{loops}. This tag can have nested
   \texttt{<directory>}, \texttt{<file>} or \texttt{<foreach>} tags.
   The current value of the iterator inside the \texttt{<foreach>} block
   can be accessed through the \texttt{arguments} attribute.
\end{itemize}

\subsection{The \texttt{<file>} Tag}
Reads a source file at the current directory (relative to the
location of \texttt{template.xml}), and transforms it to a destination
file, where the definitions of a certain Python template class are used.
\paragraph{Attributes}
\begin{description}
\item[\texttt{src}] (mandatory) the name of the source file relative
   to the directory in which \texttt{template.xml} is located or
   relative to the directory currently set by an enclosing
   \texttt{<directory>} tag.
\item[\texttt{dest}] (optional) the name of the destination file
   relative to the current destination directory. If not specified
   the name of the source file is used.
\item[\texttt{class}]
   \seealso{Appendix~\ref{appendix:template-classes}}
   (mandatory) the name of the Python class
   used to translate the file (s. Appendix~\ref{appendix:template-classes}).
\item[\texttt{arguments}] (optional) in combination with wildcard symbols
   in the \texttt{src} and \texttt{dest} arguments, this attribute contains
   a comma seperated list of names defined by an enclosing iterator.
\item[\texttt{usedby}] (optional) indicates which component of \golem{}
   is responsible for the translation. Currently the values \texttt{qgraf},
   \texttt{olp} and \texttt{reduze} are in use.
\end{description}

\paragraph{Nested Tags}
\begin{itemize}
\item \texttt{<only>} generates the file only if a condition is true,
\item \texttt{<except>} generates the file except if a condition is true.
\item \texttt{<filter>} applies a filter to the output file before it is
   written to disk. Currently, there is only one filter defined:
   the tag \texttt{<filter name="Fortran90" width="80"/>} formats the
   output such that lines longer than 80 characters are wrapped using
   the Fortran90 line break syntax ('\texttt{\&}').
\end{itemize}

\subsection{The \texttt{<directory>} Tag}
\paragraph{Attributes}
The possible attributes are \texttt{src}, \texttt{dest} and
\texttt{arguments} with the same meaning as in the \texttt{<file>} tag.

\paragraph{Nested Tags}
The possible nested tags are \texttt{<only>} and \texttt{<except>}
with the same meaning as for the \texttt{<file>} tag.

\paragraph{Note:} both \texttt{src} and \texttt{dest} can have the
value \texttt{"."}, which refers to the current directory.

\subsection{The \texttt{<foreach>} Tag}
\paragraph{Attributes}
\begin{description}
\item[\texttt{iterator}] The name of an iterator used in this loop.
Currently, only \texttt{helicities}, \texttt{crossings} and \texttt{loops} are defined.
\end{description}

\paragraph{Nested Tags}
\begin{itemize}
\item \texttt{<file>}
\item \texttt{<directory>}
\item \texttt{<foreach>}
\end{itemize}

\subsection{The \texttt{<except>} and \texttt{<only>} Tags}
\paragraph{Attributes}
Only one of the \texttt{if-...} attributes should be specified:
\begin{description}
\item[\texttt{if-file}] possible values are \texttt{exists} and
\texttt{generated}. If the value is \texttt{exists} \golem{} checks
whether or not the file is present in the current output directory.
If the value is \texttt{generated} \golem{} checks whether it has
generated this file already by an earlier statement during this run.
\item[\texttt{if-extension}] the value is a comma separated list of
extensions. The program checks if these extensions are activated.
The behaviour how to combine the elements of the list
can be modified by the optional attribute
\texttt{required}, which can take the values \texttt{all}, \texttt{some}
and \texttt{none}. If \texttt{required} is not given \texttt{all} is assumed,
which means that all extensions have to be present. \texttt{some} requires
that at least one of the extensions is activated. The value \texttt{none}
requires that none of the listed extensions is activated.
\item[\texttt{if-option}] the value should be the name of an option.
As a second attribute the user has to specify either \texttt{value}
or \texttt{list}. If \texttt{value} is given the value of the option
is compared to the value given by \texttt{value}. If \texttt{list} is
given, the argument of \texttt{list} consists a comma seperated list
of values. In this case it is checked if the value of the option is
a member of the list.
\item[\texttt{if-internal}] Checks an internal symbol whether its value
is true or false.
\item[\texttt{in-mode}] if given, the condition is only applied if the
\emph{mode} is equal to the argument. The default is that the mode is
\texttt{normal}. If everything is built from scratch  the mode is
different from \texttt{normal}.

\end{description}

\section{Template Markup Syntax}
\lstset{language=[fortran]gosamt}
\subsection{Simple Tags}
Template files are a mixture of text which is copied to the output file in
verbatim and tags enclosed in \lit{[\%} and \lit{\%]}. In the simplest
case, a tag contains only a variable name, e.g.
\begin{lstlisting}
   real(ki), dimension([%num_legs%]) :: vecs
\end{lstlisting}
In the output, the sequence \lit{[\%num\_legs\%]} is replaced by the
actual number of external particles in the process.
Any tag can have arguments. \golem{} distinguished positional arguments,
i.e. arguments bound by the order in which they appear, and named
arguments. As an example, consider the tag
\begin{lstlisting}
[% eval ( a + 10 ) * b format=%05d %]
\end{lstlisting}
While \lit{eval} is the name of the tag, the tokens
\lit{(}, \lit{a}, \lit{+}, \lit{10}, \lit{)}, \lit{*} and \lit{b}
are positional arguments. This example contains one named argument,
\lit{format}, which has the value \lit{\%05d}.

\attention{} Since the parser is
kept as simple as possible it is important to put white space in
the correct places: e.g. one has to write \lit{( a + 10 )} instead of
\lit{(a+10)}, as the latter one would be a single token. Moreover,
it is not allowed to put a space before or after the \lit{=} sign
in a named argument.

\begin{quotation}
\small\sf
Before a template is processed, the Python program creates an
object of the template class indicated in the XML file.
A tag is evaluated by the Python code by invoking the method
of the same name as the tag name with the arguments given to the tag.
The return value of the method can be
\begin{itemize}
\item a character string (use as a normal function or symbol),
\item an iterator of property sets (use in a for-loop),
\item a property set (use as an environment in a with-statement).
\end{itemize}
The previous example would lead to the call
\begin{lstlisting}[language=Python]
template.eval("(", "a", "+", "10", ")", "*", "b", \
     format="%05d")
\end{lstlisting}
\end{quotation}

\subsection{Modifying the Parser}
The delimiters \lit{[\%} amd \lit{\%]} can be changed to some other
sequence at the beginning of the file. If one puts the sequence
\lit{\%=\$} as the first three characters of the template file
the delimiters of the tags are \lit{[\$]} and \lit{\$]}.
In principle, any other character would also work instead of the dollar
sign but for clarity only \lit{\%} and \lit{\$} should be used.

\subsection{Commentary}
One can leave commentary in a template file which is not written to the
output file. A commentary tag is indicated by an apostrophy instead of
a tag name:
\begin{lstlisting}[language=gosamt]
Hello Wo[% ' some commentary %]rld!
\end{lstlisting}
This sequence would simply produce \lit{Hello World!}.

\subsection{Control Structures}
The \golem{} template language knows XX different control structure:
\begin{description}
\item[\texttt{@if}] conditional evaluation based on a logical expression
\item[\texttt{@select}] conditional evaluation based on the comparison
    of values
\item[\texttt{@for}] repetition
\item[\texttt{@with}] local environments
\item[\texttt{@macro}] parametrized reusable code block
\end{description}

\paragraph{Conditional Evaluation I}
The syntax of an if-statement is as follows
\begin{lstlisting}[language=gosamt]
[% @if tagname arguments ... %]
   Block used if expression evaluates to true
[% @elif tagname arguments ... %]
   Any number (including zero) elif-blocks
   are allowed. An elif-block is used if all
   earlier expressions evaluate to false but
   this expression evaluates to true.
[% @else %]
   The else block can be omitted. It is used
   if all conditions evaluated to false.
[% @end @if %]
\end{lstlisting}

Example:
\begin{lstlisting}
use config, only: ki[%
@if extension samurai %]
use msamurai[%
@end @if %]
\end{lstlisting}

Sometimes one needs to negate a condition. The simplest construction
to do so is to put nothing in the first branch but only output text
in the else-branch:
\begin{lstlisting}
[% @if generate_lo_diagrams
      %][%
   @else %]
complex(ki), dimension(numcs, -2:0) :: colorvec
integer :: c[%
   @end @if %]
\end{lstlisting}

\paragraph{Conditional Evaluatation II}
The syntax of the select-statement is as follows
\begin{lstlisting}[language=gosamt]
[% @select tagname arguments ...
   @case value1 value2 ... %]
   Block used if expression evaluates to one of
   the values following @case
[% @case value3 value4 ... %]
   Any number (including zero) of case-blocks
   are allowed. A case-block is used if all
   earlier case blocks were not used.
[% @else %]
   The else block can be omitted. It is used
   if all previous blocks were skipped.
[% @end @select %]
\end{lstlisting}

A select statement can be a simpler replacement for an if-statement.
Consider the following example:
\begin{lstlisting}
[% @if eval num_legs .eq. 1 %]stop[% @end @if %]
\end{lstlisting}
The equivalent select statement would be
\begin{lstlisting}
[% @select num_legs @case 1 %]stop[% @end @select %]
\end{lstlisting}
There is no need to invoke the \texttt{eval} method here.
Sometimes the use of arguments makes it even impossible to
find an equivalent if-statement for a select-statement:
\begin{lstlisting}
[% @select count particles lightlike vector colored
   @case 0 %][%
   @else %]
print, "Process has gluons."[%
   @end @select %]
\end{lstlisting}

\attention{} Note that the select statement only uses at most one
block. Therefore it uses a Fortran-like semantics (rather than
a C-like semantics where all subsequent blocks are used unless
a break-statement is met).

\paragraph{Repetition}
There is only definite repetition in the template language\footnote{
There is no indefinite while-statement, which would only make sense
in an imperative language where the loop-body can produce side effects.}.
The syntax of the loop is as follows
\begin{lstlisting}[language=gosamt]
[% @for tagname arguments ... %]
Block is evaluated for each element in the
iterator defined by the tag name.
[% @end @for %]
\end{lstlisting}

The following example computes the color average factor for a given
process:
\begin{lstlisting}
color_avg = 1.0_ki[%
@for particles initial %][%
   @select color
   @case -3 3 %]/NC[%
   @case  8 %]/(NC*NC-1.0_ki)[%
   @end @select %][%
@end @for %]
\end{lstlisting}
\attention{}The main iteration variable is usually called \lit{\$\_}.
Most iterators define the symbols \texttt{is\_first}
and \texttt{is\_last}. One application are comma seperated lists
\begin{lstlisting}
[%
@for particles colored %][%
   @if is_first %]
partons = (/[%
   @else %], [%
   @end @if %][% $_ %][%
   @if is_last %]/)[%
   @end @if %][%
@end @for %]
\end{lstlisting}
This block produces nothing if the process does not have external
colored particles. Otherwise it produces an assignment which
sets \texttt{partons} to a list of particle indices which are partons.

\paragraph{Environments}
The syntax of a with statement is as follows.
\begin{lstlisting}[language=gosamt]
[% @with tagname arguments ... %]
Block is evaluated as usual but might
have additional symbols defined.
[% @end @with %]
\end{lstlisting}

One use of with statements is to store more complex expressions
in a single symbol which can be used inside the \texttt{eval}
tag:
\begin{lstlisting}
[% @with eval x + y result=z %]
Five times x plus y is [% eval 5 * z %][%
   @end @with %]
\end{lstlisting}

One could also use a with-block in order to access currently set
shell variables:
\begin{lstlisting}
[% @with os prefix=shell. %]
character(len=255), parameter :: host_name = [%
  ' ignore line break %] "[% shell.HOST %]"
[% @end @with %]
\end{lstlisting}
In the above example a commentary tag has been used to hide a
line break from the output.

\paragraph{Macros}
The syntax of a macro definition is the following:
\begin{lstlisting}[language=gosamt]
[% @macro name arg1 arg2 ... opt_arg1=value1 ...
%]Macro body which may depend on [% arg1 %] ...
and the optional arguments such as [% opt_arg1 %][%
   @end @macro %]
\end{lstlisting}

\attention{} The \texttt{@macro} block itself does not generate
any output. Only when the macro is called its body is evaluated.

Example:
\begin{lstlisting}
module my_kinematics[%
@macro def_particle index mass=0 %]
real(ki), dimension(4) :: k[% index %][%
   @select mass @case 0 %][%
   @else %]
real(ki) :: m[% index %] = [% mass %][%
   @end @select %][%
@end @macro %]
[% def_particle 1 %]
[% def_particle 2 %]
[% def_particle 3 mT %]
[% def_particle 4 mT %]
\end{lstlisting}

\chapter{Some Coding Examples}

\section{A New Variable in \texttt{config.f90}}
The following section provides a small example which at the same time
consists one of the most common tasks: an additional configuration option
is introduced in the Fortran code and used in some other part of the code.

Section~\ref{ssec:nlo-prefactors:01} describes what needs to be done in
any case. The steps described here should be familiar to anybody seriously
developing or extending \golem{}. The later subsections 
\ref{ssec:nlo-prefactors:02} to \ref{ssec:nlo-prefactors:04} are intended
for the more experienced and interested audience: they involve several
levels of the templates and of the code but conversely are of lower
importance in daily business. Skipping them should not influence the
understanding of the rest of the manual significantly.

\subsection{Background}
In the first public version of \golem{}, the results of the generated code
 were explained only for the case where the coupling constants
$g_s$ and $e$ are set to one.
The effects of setting these constants to any other value
have been somewhat difficult to understand.

We try to improve the code by introducing an integer variable
\texttt{nlo\_prefactors} in \texttt{common/config.f90} which
offers the following options:
\begin{description}
\item[\texttt{0}:] A factor of $\alpha_s/(2\pi)$ (resp. $\alpha/(2\pi)$
for QED/EW corrections) is not included in the result, regardless of the
settings of $e$ and $g_s$.
\item[\texttt{1}:] A factor of $1/(8\pi^2)$ is not included in the result.
\item[\texttt{2}:] The full result including $\alpha_{(s)}/(2\pi)$ is
returned.
\end{description}
In any case, the factor $1/\Gamma(1-\varepsilon)$ is not included.

We already included a division of the virtual part by the respective coupling
in order to provide a result with $\alpha_{(s)}/(2\pi)$ factored out in all
cases, also if $g_s$ or $e$ was not equal to one. In order to do so
the symbols \lstinline{[% QCD_COUPLING_NAME %]}
and \lstinline{[% QED_COUPLING_NAME %]}
have been introduced. Furthermore, we will make use of the
variable \texttt{corrections\_are\_qcd} defined in
\texttt{common/kinematics.f90} to distinguish between QCD and QED
corrections.

\subsection{The Minimalist Approach}
\label{ssec:nlo-prefactors:01}
As we would like to have \texttt{nlo\_prefactors=0} as the default,
in a first step we add the following lines to the file
\texttt{templates/\hspace{0pt}common/\hspace{0pt}config.f90}.
\begin{lstlisting}
! Determines the way GoSam treats the overall
! factor of alpha_(s)/2/pi in the NLO result.
! 0: A factor of alpha_(s)/2/pi is not included
! 1: A factor of 1/8/pi^2 is not included
! 2: The NLO includes all prefactors
integer :: nlo_prefactors = 0
\end{lstlisting}
\attention Please not that in order to put this change into effect in an
already existing process directory you need to remove \texttt{config.f90}
there manually or force gosam to overwrite it with the \texttt{--scratch}
option\footnote{This option will also affect the files \texttt{Makefile.conf}
and \texttt{matrix/test.f90}.}

The second step is a modification of the file
\texttt{templates/\hspace{0pt}matrix/\hspace{0pt}matrix.f90}:
here we need to adapt the results
of the two routines \texttt{samplitude} and
\texttt{ir\_subtraction}. First, we define the square of the coupling
constant which is relevant in our process, i.e. either $g_s^2$ or $e^2$.
In both the routines we add the local variable
\begin{lstlisting}
real(ki) :: nlo_coupling
\end{lstlisting}
and later in the routines we initialize it by the following lines
\begin{lstlisting}
if(corrections_are_qcd) then[%
@select QCD_COUPLING_NAME
@case 0 1 %]
   nlo_coupling = 1.0_ki[%
@else %]
   nlo_coupling = [%QCD_COUPLING_NAME%]*[%
        QCD_COUPLING_NAME%][%
@end @select %]
else[%
@select QED_COUPLING_NAME
@case 0 1 %]
   nlo_coupling = 1.0_ki[%
@else %]
   nlo_coupling = [%QED_COUPLING_NAME%]*[%
        QED_COUPLING_NAME%][%
@end @select %]
end if
\end{lstlisting}
Of course, we could have opted for a more complicated template
expression avoiding the if-statement all together in the case
when both, QED and QCD coupling are fixed.

In the routine \texttt{ir\_subtractions}, we need to import the
symbols \texttt{corrections\_are\_qcd} and the names of the
couplings. Therefore we extend the \texttt{use} statements.\footnote{
In the routine \texttt{samplitude} these symbols are already imported.}
On top of that also the symbol \texttt{nlo\_prefactors} is needed.
\begin{lstlisting}
use [%process_name asprefix=\_%]config, &
   & only: nlo_prefactors
use [%process_name asprefix=\_%]kinematics
use [%process_name asprefix=\_%]model
\end{lstlisting}

At the end of the two routines we need to add the statements
multiplying in the relevant factor depending on the value
of  \texttt{nlo\_prefactors}. 
Note that the indices of \texttt{amp} are different for the two routines.
\begin{lstlisting}
select case(nlo_prefactors)
case(0)
   ! The result is already ok
case(1)
   amp(2:4)=amp(2:4)*nlo_coupling
case(2)
   amp(2:4)=amp(2:4)*nlo_coupling/8._ki/pi/pi
end select
\end{lstlisting}

\subsection{Adding the Option to \texttt{parseline}}
\label{ssec:nlo-prefactors:02}
Although what we programmed so far is a fully working implementation
we would like to add a bit of luxury for the user: we would like
the function \texttt{parseline} in \texttt{common/\hspace{0pt}model.f90}
to recognize settings of our newly defined variable \texttt{nlo\_prefactors}
read from text files or, in the context of the BLHA interface,
through the routine \texttt{OLP\_Option}.

The additional complication with respect to the previously modified
files is the fact that \texttt{model.f90} is not generated directly
by \golem{} but from the make files using \haggies{}. Therefore we
need to modify the file
\texttt{templates/\hspace{0pt}codegen\hspace{0pt}/model.out}.

When looking at the file in the editor we recognize that the file
starts with
\lstset{language=[haggies]{gosamt}}
\begin{lstlisting}
%=$[$ ' vim:syntax=golem
$]module     [$ process_name asprefix=\_ $]model
\end{lstlisting}
The first three digits \lit{\%=\$} change the markup format from
\lit{[\% ... \%]} to \lit{[\$ ... \$]}. This is necessary because
the former coincides to be the markup syntax of \haggies{}, too.
By changing the markup syntax, the format with the percent signs
is treated as plain text by \golem{}, only the format with the
dollar signs is recognized as markup.

In the subroutine \texttt{parseline} we localize the block staring
with the line
\begin{lstlisting}
if (name .eq. "renormalization") then
\end{lstlisting}
and we add the block
\begin{lstlisting}
elif (name .eq. "nlo_prefactors") then
   re = parsereal(value, ierr, lnr)
   if (ierr .ne. 0) then
      stat = 1
      return
   end if
   nlo_prefactors = int(re)
\end{lstlisting}

Furthermore, we add the variable import of \texttt{nlo\_prefactors}
to the \texttt{use} statement at the beginning of the module
\begin{lstlisting}
use [$ process_name asprefix=\_ $]config, ...&
    & ... &
    & nlo_prefactors
implicit none
private :: nlo_prefactors
\end{lstlisting}

\subsection{Adding an Option to the Input File}
\label{ssec:nlo-prefactors:03}
After having the option \texttt{nlo\_prefactors} added to the
\texttt{parseline} routine,
it would be even more of a luxury for the user if he had the possibility
to define already in the input file (i.e. before running \golem{}) what
setting for \texttt{nlo\_prefactors} he would like to see in the file
\texttt{config.f90}, without having to modify that file and without the
need of setting the value at runtime. This can be achieved by adding
the default value in \texttt{config.f90} as a template variable.

We open the file \texttt{templates/\hspace{0pt}common\hspace{0pt}/config.f90}
and replace the declaration of \texttt{nlo\_prefactors} by
\lstset{language=[fortran]{gosamt}}
\begin{lstlisting}
integer :: nlo_prefactors = [% nlo_prefactors
     convert=number
     default=0 %]
\end{lstlisting}
The argument \lit{convert=number} is not necessary but reduces the risk
of typos propagating through and being detected only when the file is
compiled. The argument \lit{default=0}, however, is necessary, as long
as we have not defined a default-value elsewhere. Leaving out the
\texttt{default} argument would cause an error if the input file does
not define \texttt{nlo\_prefactors}.

At this level, \golem{} does not know anything about the existence of
the template variable \texttt{nlo\_prefactors}; it is now a
user-defined preprocessor variable which could be added to the input
file by the user and would be passed through behind the scenes to any
template file.
Although this, in principle, is a sufficient solution for our purpose,
it should be noted that user-defined variables come with a couple of
drawbacks:
\begin{itemize}
\item There is no proper error checking possible on the values of
      the variable.
\item In generated template files there is no section for the
      user-defined variable and therefore it might be difficult
      to find out about its existence.
\item In the interactive mode this variable would not be visible
      either.
\item The variable is not automatically added to the appendix of
      the user manual.
\end{itemize}

In order to promote our user-defined variable to a built-in variable
touching some lines of \python{} code is unavoidable. However, the
required modifications are very small. The central location to define
new built-in template variables (or \emph{properties}) is the file
\texttt{src/\hspace{0pt}python/\hspace{0pt}golem/\hspace{0pt}%
properties.py}, where we have to proceed in two steps,
\begin{enumerate}
\item defining the new property and
\item adding it to the global variable \texttt{properties}.
\end{enumerate}

The first step is done by adding the following lines:
\begin{lstlisting}[language=Python]
config_nlo_properties = Property("nlo_prefactors",
   """
   Set the same variable in config.f90.
   The values have the following meaning:
   ...
   """,
   int, 0, options=[0,1,2])
\end{lstlisting}
The first argument of the constructor \texttt{Property}
is the name of the variable in the input file\footnote{%
The name \texttt{config\_nlo\_properties} has only local meaning.}.
The second argument provides some documentation about the new
property, followed by its type and default value as third and fourth
argument. The optional argument \texttt{options} defines a list of
valid values for this variable.

A further optional argument would be \texttt{experimental}.
If it is set to \texttt{True} the property is marked as experimental,
which means that
\begin{itemize}
\item setting it in the input file produces a warning and
\item it is not added to new template files or to the documentation.
\end{itemize}

After having added the property to the list \texttt{properties},
\begin{lstlisting}[language=Python]
properties = [
   process_name,
   ...
   config_nlo_properties,
   ...
]
\end{lstlisting}
all benefits of a built-in variable are in place. Therefore,
setting \texttt{nlo\_properties=5} would result in the warning:
\begin{verbatim}
-->  The value (5) of option 'nlo_prefactors'
     is not in the valid range.
\end{verbatim}

As a last step we better remove the \texttt{default} argument in
\texttt{config.f90} to avoid overwriting the default value from
\texttt{properties.py}. Since now the data type of the variable
is declared correctly we can also skip the argument \texttt{convert}:
\begin{lstlisting}
integer :: nlo_prefactors = [% nlo_prefactors %]
\end{lstlisting}

\subsection{Adding a Parameter to the Interactive Interface}
\label{ssec:nlo-prefactors:04}
Despite of its shadowy existence, the interactive mode of \golem{}
can be an interesting playground for trying out new features.
The more it is important to add some extra level of luxury for our
new option also there.

After having added the variable to \texttt{properties.py} it is already
automatically added to the list of tab-completions in \golem{}'s interactive
mode, which is started by running \texttt{gosam -i}.
Typing \lit{nlo} at the prompt followed by hitting the \lit{Tab} key is
enough to trigger the auto-completion, and the input line now reads
\lit{nlo\_prefactors} followed by a white space. Hitting the \lit{Tab} key
again, however, does not help us in remembering the set of allowed variables.
What we would like to have is the auto-completion printing the list of
valid options to the screen. In order to enable this feature, we simply
edit the \python{} file
\texttt{src/\hspace{0pt}python/\hspace{0pt}golem/\hspace{0pt}%
shell.py}. In the \texttt{\_\_init\_\_} function of the class
\texttt{GolemShell} we find an assignment to
\texttt{self.golem\_follow\_set}, where we add the entry:
\begin{lstlisting}[language=Python]
str(golem.properties.config_nlo_prefactors):
   ["0", "1", "2"],
\end{lstlisting}
That's all, we are done!

\section{Numerical Polarization Vectors}
This section describes a \emph{project} rather than an example:
we are not only going to modify the generated code but also the
structure of the numerators. This is a good example for everybody who
wants to dig deeper in the code structure of \golem{}.
The reader will have to learn about \form{} and \haggies{} as we are going
to extend the list of symbols that can appear in an expression.
Less emphasis is on the Fortran part of the code: here we will only add
the code to initialize the numerical representation of the polarisation
vectors.

\subsection{Background}
When \golem{} generates an expression for each diagram the wave functions
(spinors, polarisation vectors, \dots) are replaced at the algebraic
level by a helicity projection. Besides all advantages of such an approach
there is one big draw-back: for amplitudes with many external gauge bosons
the number of helicity amplitudes explodes exponentially. In the worst case
one needs to generate a seperate directory for each helicity amplitude.
By mapping helicity-amplitudes which are related by permutation symmetry
this problem can be softened but not completely removed.

Since the polarisation vectors of massless gauge bosons are (complex)
light-like vectors the algebra can be carried out without any modifications
even if the polarisation vectors are left in the expressions as extra symbols:
instead of substituting, for example,
\begin{equation}\label{eq:def-epsplus}
\epsilon^\mu_+(k_i, r_i)\to\frac{\langle r_i\vert\gamma^\mu\vert k_i]}%
{\sqrt{2}\langle r_ik_i\rangle}
\end{equation}
we just introduce a new symbol
$\mathtt{eps1}\equiv\epsilon_1=\epsilon^\mu_\pm(k_1, r_1)$
together with all relevant spinor products $\langle r\epsilon_1\rangle$
and $[r\epsilon_1]$.

Whether this procedure leads to a more efficient implementation is difficult
to decide in general. Therefore we leave this new feature as an extension
which the user can switch on and of per process.

\subsection{Spinor Products of Polarization Vectors}
In order to construct the spinor products $\langle v\epsilon_i\rangle$
and $[v\epsilon_i]$ we first write down $\fmslash{\epsilon}_i$, as it is
\begin{align}
\fmslash{\epsilon}_+(k_i, r_i) &=\frac{\sqrt{2}}{\langle r_ik_i\rangle}
\left(\vert k_i]\langle r_i\vert + \vert r_i\rangle[k_i\vert\right),\\
\fmslash{\epsilon}_-(k_i, r_i) &=\frac{\sqrt{2}}{[k_ir_i]}
\left(\vert k_i\rangle[r_i\vert + \vert r_i]\langle k_i\vert\right).
\end{align}
From the contractions $[v\vert\fmslash{\epsilon}_+\vert k_i\rangle$
and $\langle v\vert\fmslash{\epsilon}_+\vert r_i]$ we can read off
the relations
\begin{align}
[v\epsilon_+] &= \sqrt{2}\frac{[vk_i]}{\langle\epsilon_+k_i\rangle},\\
\langle v\epsilon_+\rangle &=\sqrt{2}\frac%
{\langle vr_i\rangle[k_ir_i]}{[\epsilon_+r_i]\langle r_ik_i\rangle}
\end{align}
Furthermore, it is trivial to see that $\langle\epsilon_+r_i\rangle$
and $[\epsilon_+k_i]$ both are zero.
This does not solve the problem completely but reduces it to the need to know
$\langle\epsilon_+k_i\rangle$ and $[\epsilon_+r_i]$. Replacing
$v=k_i$ or $v=r_i$ in the above equation (which is equivalent to
using the normalization condition $\epsilon_+\cdot\epsilon_-=-1$)
yields
\begin{equation}
[r_i\epsilon_+]\langle\epsilon_+k_i\rangle = \sqrt{2}[r_ik_i]
\end{equation}

With the Gordon identity we can write
\begin{equation}
2\epsilon_+^\mu=\langle\epsilon_+\vert\gamma^\mu\vert\epsilon_+]
=\frac{\sqrt{2}}{\langle r_ik_i\rangle}\langle r_i\vert\gamma^\mu\vert k_i]
\end{equation}
We can now attempt the identification
\begin{align}
\vert\epsilon_+\rangle &\equiv\sqrt{\frac{\sqrt{2}}{\langle r_ik_i\rangle}}
   \vert r_i\rangle
\quad\text{and}\\
\vert\epsilon_+] &\equiv\sqrt{\frac{\sqrt{2}}{\langle r_ik_i\rangle}}
   \vert k_i]
\end{align}
This choice reproduces all relevant relations. For the negative polarisation
case we choose
\begin{align}
\vert\epsilon_-\rangle &\equiv\sqrt{\frac{\sqrt{2}}{[k_ir_i]}}
   \vert k_i\rangle
\quad\text{and}\\
\vert\epsilon_-] &\equiv\sqrt{\frac{\sqrt{2}}{[k_ir_i]}}
   \vert r_i]
\end{align}

\subsection{Adding an Extension}
When a new feature is added to the code it is always a good idea to add it
as an \emph{extension}. Extensions are key words which can be added by
the user to the option \texttt{extensions} or to any option of the
form \texttt{*.extensions}, such as \texttt{my.extensions},
\texttt{extra.extensions}, \texttt{system.extensions} and so on.
This mechanism of allowing for
several variables for extensions prevents overwriting already set extensions
for example when information from different setup files is merged into one.

The code should always\footnote{There are well-motivated exceptions from
this rule} be written in a way that \emph{doing nothing changes nothing},
i.e. if the user does not put this exception explicitly the behaviour of
the program does not change. On the other hand, after a couple of versions
it might become obvious that 90\% of the users always work \emph{with}
this new extension, so it is cumbersome to always add it. It might become
more natural to introduce an extension \texttt{no-supercalifragilistic}
which only 10\% of the users have to add
rather than \texttt{supercalifragilistic} which is found in the configuration
files of 90\% of the users. For this reason the concept
of \emph{internals} has been introduced: it creates an intermediate level
between the user view (extension) and the templates. The example will
make this clearer.

In our specific case, the extension is called \texttt{numpolvec},
which seems to be a good compromise between the very self-documenting
but keyboard-intense \texttt{numerical-polarisation-vectors} and the
cryptic opposite \texttt{npv}.

In principle adding a new extension is at no cost: similar to the
user-defined variables which can be accessed at any time in the templates
without having to modify a piece of Python code
(see Section~\ref{ssec:nlo-prefactors:03}), one could also access
an extension without having to declare it anywhere. The template
code is straight-forward, e.g.
\begin{lstlisting}
[% @if extension numpolvec %]
... work with numerical polarisation vectors ...
[% @else %]
... work without ...
[% @end @if %]
\end{lstlisting}
That's it. Very simple but difficult to maintain as you might end up
with dozens of such if-statements spread around all your template files.

The recommendation therefore is to introduce an internal variable
with each new extension. This is not much more difficult than the
if statement before. In the file
\texttt{src/\hspace{0pt}python/\hspace{0pt}golem/\hspace{0pt}properties.py},
we need to add two lines to the function \texttt{setInternals}.
First of all, we add \texttt{"\_\_NUMPOLVEC\_\_"} to the list of internals
\begin{lstlisting}[language=Python]
conf["__INTERNALS__"] = [
   ...
   "__NUMPOLVEC__"
]
\end{lstlisting}
The second modification of this function is the assignment
\begin{lstlisting}[language=Python]
conf["__NUMPOLVEC__"] = "numpolvec" in extensions
\end{lstlisting}

Accessing an internal symbol is as easy as accessing an extension:
\begin{lstlisting}
[% @if internal NUMPOLVEC %]
... work with numerical polarisation vectors ...
[% @else %]
... work without ...
[% @end @if %]
\end{lstlisting}
However, the advantage of using internals becomes apparent very
quickly: if at some point we would like to make the use of numerical
polarisation vectors the default we remove the extension \texttt{numpolvec}
and replace it by the extension \texttt{no-numpolvec} or \texttt{algpolvec}
or anything similar. The only modification in the code would be the
assignment to \texttt{conf["\_\_NUMPOLVEC\_\_"]},
\begin{lstlisting}[language=Python]
conf["__NUMPOLVEC__"] = "no-numpolvec" \
     not in extensions
\end{lstlisting}
We do not need to touch any of our template files.

Being user friendly, we add our changes also to the variable
\texttt{extensions} in the same file \texttt{properties.py}:
the documentation gets the additional line
\begin{verbatim}
numpolvec    --- evaluate polarisation vectors numerically
\end{verbatim}
and the optional argument \texttt{options} in the constructor
\texttt{Property} is extended by the additional entry
\texttt{"numpolvec"} -- otherwise \golem{} would spit out a warning
every time it encounters the `unknown' extension \texttt{numpolvec}.

The first obstacle is take now: the user can add the extension
\texttt{numpolvec} to his input files, we can access the internal
\texttt{NUMPOLVEC} in our template files --- but so far, nothing changed.

\subsection{Initializing the New Symbols Numerically}
We would like to initialize the polarisation vectors and the
symbols derived from them in the module
\texttt{common/\hspace{0pt}kinematics.f90} in the subroutine
\texttt{init\_event}. In order to pass the relevant helicity information
we have already added dummy parameters, one per gauge boson.
In the template file
\texttt{templates/\hspace{0pt}common/\hspace{0pt}kinematics.f90}
this is realized by a loop over all lightlike spin 1 (key word
\lit{vector}) particles:
\begin{lstlisting}
   subroutine init_event(vecs[%
@for particles lightlike vector %], hel[%index%][%
@end @for %])
      use [% process_name asprefix=\_ %]model
      implicit none
      real(ki), dimension(num_legs,4), &
     &         intent(in) :: vecs[%
@for particles lightlike vector %]
      integer, optional, &
     &         intent(in) :: hel[%index%][%
@end @for %]
\end{lstlisting}

Before we can initialize anything we need to declare the relevant
symbols at the module level. These global declarations are generated
by a couple of \texttt{particles} and \texttt{pairs} loops.
For the declaration of the polarisation vectors we can use exactly
the same construction that we already had for the arguments.
\begin{lstlisting}
[% @if internal NUMPOLVEC %][%
   @for particles lightlike vector %]
complex(ki), dimension(4), public :: e[%
      index %][%
   @end @for %]
\end{lstlisting}

For pairs of particles the keywords \texttt{lightlike} and
\texttt{vector} are not implemented. Therefore we need to use
a construction like the following:
\begin{lstlisting}
[%
@for pairs ordered distinct %][%
   @if eval is_lightlike2
      .and. ( 2spin2 .eq. 2 ) %]
complex(ki), public :: spa[%
      @if is_lightlike1 %]k[%
      @else %]l[%
      @endif %][% index1 %]e[% index2 %][%
   @end @if %][%
@end @for %]
\end{lstlisting}
In a similar way we also declare symbols for $\langle e_i\vert e_j\rangle$
and $\langle e_i\vert\gamma^\mu\vert k_j]$ etc.

Now we can turn our attention back to the routine
\texttt{init\hspace{0pt}\_event}, where the actual initialization of
these symbols is still missing. The initialization of the vectors
\texttt{e\it i} is greatly simplified by using a with statement defining
the reference vector.
\begin{lstlisting}
[%
@if internal NUMPOLVEC %]
if(.true.[%
   @for particles lightlike vector
      %] .and. present(hel[%index%])[%
   @end @for %]) then[%
   @for particles lightlike vector initial %][%
      @with eval 'k .rep. ( reference > 0 )
               . 'l .rep. ( reference < 0 )
               . reference result=refvec %]
   select case(hel[%index%])
   case(1)
      e[% index %] = sva[%refvec%]k[%index
          %]/sqrt2/Spaa([%refvec%],k[%index%])
   case(-1)
      ...
   end select[%
      @end @with %][%
   @end @for %]
end if
\end{lstlisting}

First we need to understand the expression in the with-statement:
\texttt{'k} and \texttt{'l} denote the respective letters litterally.
The operator \texttt{.rep.} produces the given number of repetitions
(including zero) of the string in front of it. The comparisons produce
either the value 0 or 1, therefore one of the two letters is repeated
once the other one zero times. The concatenation operator puts the three
parts together, producing a symbol like \lit{k4} or \lit{l4}. The
result is stored in the symbol \texttt{refvec}. The body of the with-statement
is relatively easy to understand as it only uses already known concepts.

The routine is also augmented by the loops initializing the newly defined
symbols for spinor products. It should be noted that new routines for spinor
products with complex arguments have been defined, which is not covered
in this manual.

\subsection{Adding symbol definitions in \form}
The same symbols which have just been added to the Fortran files
need to be defined also at the level of the \form{} files.
All process dependent symbol definitions are found in the file
\texttt{templates/\hspace{0pt}codegen/\hspace{0pt}symbols.hh}.
We can proceed there exactly the same way as we did in the Fortran file
by adding loops over \texttt{particles} and \texttt{pairs}, all protected
by an if-tag.
\lstset{language=[form]{gosamt}}
\begin{lstlisting}
[%
@if internal NUMPOLVEC %][%
   @for particles lightlike vector %]
Vector e[%index%];[%
   @end @for %][%
   @for pairs ordered distinct %][%
      @if eval is_lightlike2 .and.
            ( 2spin2 .eq. 2 ) %]
Symbols spa[%
         @if is_lightlike1 %]k[%
         @else %]l[%
         @end @if %][% index1 %]e[% index2
      %], spbe[% index2 %][%
         @if is_lightlike1 %]k[%
         @else %]l[%
         @end @if %][% index1 %];[%
      @end @if %][%
   @end @for %][%
@end @if %]
\end{lstlisting}
As the pedagogical value of a complete repetition of all definitions would
be very limited we skip the rest of this file. We must however not forget
to add the newly defined vectors to the definitions of \texttt{LIGHTLIKE}
and \texttt{EXTERNAL} and also in the relevant routines like
\texttt{spsymbols} and \texttt{kinematics}.

\paragraph{TODO}
\begin{itemize}
\item describe \texttt{kinematics-define.inc}
\item describe \texttt{spva.prc}
\end{itemize}

\appendix
\lstset{language=[fortran]{gosamt}}
\chapter{Available Template Classes}
\label{appendix:template-classes}

\section{Predefined Symbols}
All symbols which are defined in the list of properties
in \texttt{golem.properties} are read from the process card and
made available in any template. Furthermore, the following symbols
are set up while the input file is processed.
\begin{description}
\item[\texttt{QCD\_COUPLING\_NAME}] the name of the QCD coupling in the
current model. This equals to 1 if the coupling has been set to one,
it equals to 0 if the coupling is set to zero or if the name could not
ee determined.
\item[\texttt{QED\_COUPLING\_NAME}] the name of the QED coupling in the
current model. This equals to 1 if the coupling has been set to one,
it equals to 0 if the coupling is set to zero or if the name could not
be determined.
\item[\texttt{topolopy.keep.tree}] comma seperated list of diagram labels
(tree diagrams) which passed the filters.
\item[\texttt{topolopy.keep.virt}] comma seperated list of diagram labels
(loop diagrams) which passed the filters.
\item[\texttt{topolopy.count.tree}] number of elements in
\texttt{topolopy.keep.tree}, i.e. the number of tree level diagrams in this
process.
\item[\texttt{topolopy.count.virt}] number of elements in
\texttt{topolopy.keep.tree}, i.e. the number of loop diagrams in this
process.
\item[\texttt{generate\_lo\_diagrams}] whether or not to generate tree
diagrams (depends on the value of \texttt{order}).
\item[\texttt{generate\_nlo\_virt}] whether or not to generate loop
diagrams (depends on the value of \texttt{order}).
\item[\texttt{generate\_uv\_counterterms}] reserved for future use,
currently always set to \texttt{false}.
\end{description}
\bigskip

Any symbol can be formatted with the following arguments:
\begin{description}
\item[\texttt{substr=}{\synt{start}[\texttt{:}\synt{end}]}]
   Only extract a substring of the value indicated by the (zero-based)
   indices \synt{start} (including) and \synt{end} (excluding).
\item[\texttt{convert=}{\lit{lower}\texttt{|}%
   \lit{upper}\texttt{|}%
   \lit{bool}\texttt{|}%
   \lit{number}\texttt{|}\lit{float}}]
   The result is converted to the given type. If also \texttt{format}
   is provided, this conversion is done before formatting.
\item[\texttt{true=}\synt{true} \texttt{false=}\synt{false}]
   If \texttt{convert=bool} is supplied the symbols \synt{true}
   and \synt{false} specify the return value depending on the
   logical value of the result.
\item[\texttt{radix=}\synt{base}] If \texttt{convert=number} this
   option defines the basis in which the result is given. By default
   this is 10. If the result starts with \lit{0x} or \lit{\$} the
   base is set to 16.
\item[\texttt{match=}\synt{pattern} {[\texttt{flags=}\synt{flags}]}]
   The result is matched by a regular expression given in
   \synt{pattern}. Flags can be a string formed by any subset of the characters
   \lit{I} (ignore case), \lit{L} (locale), \lit{M} (multiline),
   \lit{S} (\lit{.} matches also new line), \lit{U} (unicode),
   \lit{X} (extended syntax).
\item[\texttt{format=}\synt{fmt}]
   The result is formatted using a Python format string.
\item[\texttt{digits=}\synt{lst}] The result is interpreted as an integer
   number being formatted with the digits given in \synt{lst}. Binary format,
   for example, can be achieved by setting \texttt{digits=01}.
\item[\texttt{asprefix=}\synt{prefix}] Adds a prefix to the result if
   the result is non-empty.
\item[\texttt{assuffix=}\synt{suffix}] Adds a suffix to the result if the
   result is non-empty.
\end{description}
\bigskip

Additional options influencing the way symbols are looked up are the following:
\begin{description}
\item[\texttt{default=}\synt{value}] The value \synt{value} is returned if
   the symbol was not defined.
\item[\texttt{suffix=}\synt{var}] Suffixes the name by the value of \synt{var}
   before it is being looked up.
   Example:
\begin{lstlisting}
[% @for repeat 5 %]
[% diagram suffix=$_ %][%
[% @end @for %]
\end{lstlisting}
   This example generates and evaluates the tags \lstinline|[% diagram0 %]|
   \ldots \lstinline|[% diagram4 %]|.
\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{The Base Class}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%---------------------------------------------------------------------
\subsection{Functions}
%---------------------------------------------------------------------
\begin{description}
\item[\texttt{anymember}
   \synt{element$_1$} {[\synt{element$_2$}\dots
   \synt{element$_n$}]} \synt{var} {[\texttt{ignore\_case=}\synt{logical}]} 
   $\to$ \synt{logical}]
   Checks whether any of the arguments \synt{element$_1$} \ldots
   \synt{element$_n$} (not interpreted as variable names) is an element of
   the comma seperated list denoted by the symbol \synt{var}.
\item[\texttt{count} \ldots $\to$ \synt{integer}] The arguments of
   \texttt{count} are interpreted as an iterator. The result is the
   number of times the iterator yields an element.
\item[\texttt{empty} \synt{var} $\to$ \synt{logical}]
   Checks whether the symbol \synt{var} denotes an empty list.
\item[\texttt{error} \synt{error message}] This tag does not produce any code.
   The error message is printed and the program is stopped when this
   symbol is processed.
\item[\texttt{eval} \ldots $\to$ \synt{string}]
   This function interprets its arguments as tokens of an expression and
   evaluates it. The expression is evaluated from left to right obeying
   the following operator precedence. Parentheses can be used for changing
   the evaluation order.
   \begin{center}
   \begin{longtable}{|c|p{12em}|r|}
   \hline
   {\bf Operation}&
   {\bf Description}&
   {\bf Prec.}\\
   \hline
\endhead
   \hline
\endlastfoot
   $x\,\mathtt{|}\,y$ & logical \emph{or} & 100\\
   $x\,\mathtt{||}\,y$ & logical \emph{or} & 100\\
   $x\,\mathtt{.or.}\,y$ & logical \emph{or} & 100\\
   $x\,\mathtt{\&}\,y$ & logical \emph{and} & 150\\
   $x\,\mathtt{\&\&}\,y$ & logical \emph{and} & 150\\
   $x\,\mathtt{.and.}\,y$ & logical \emph{and} & 150\\
   $\mathtt{!}\,x$ & logical \emph{not} & 200\\
   $\mathtt{.not.}\,x$ & logical \emph{not} & 200\\
   $x\,\mathtt{.eq.}\,y$ & comparison $x=y$ & 255\\
   $x\,\mathtt{<}\,y$ & comparison $x<y$ & 255\\
   $x\,\mathtt{.lt.}\,y$ & comparison $x<y$ & 255\\
   $x\,\mathtt{>}\,y$ & comparison $x>y$ & 255\\
   $x\,\mathtt{.gt.}\,y$ & comparison $x>y$ & 255\\
   $x\,\mathtt{.ge.}\,y$ & comparison $x\geq y$ & 255\\
   $x\,\mathtt{.geq.}\,y$ & comparison $x\geq y$ & 255\\
   $x\,\mathtt{.le.}\,y$ & comparison $x\leq y$ & 255\\
   $x\,\mathtt{.leq.}\,y$ & comparison $x\leq y$ & 255\\
   $x\,\mathtt{<>}\,y$ & comparison $x\neq y$ & 255\\
   $x\,\mathtt{.ne.}\,y$ & comparison $x\neq y$ & 255\\
   $x\,\mathtt{.neq.}\,y$ & comparison $x\neq y$ & 255\\
   $x\,\mathtt{\sim<}\,y$ & $x$ starts with $y$ (str) & 255\\
   $x\,\mathtt{\sim>}\,y$ & $x$ ends with $y$ (str) & 255\\
   $x\,\mathtt{\sim}\,y$ & $x$ contains $y$ (str) & 255\\
   $x\,\mathtt{+}\,y$ & sum, $x+y$ & 300\\
   $x\,\mathtt{-}\,y$ & difference, $x-y$ & 300\\
   $x\,\mathtt{.}\,y$ & string concatenation, $xy$ & 300\\
   $x\,\mathtt{.max.}\,y$ & maximum, $\max(x,y)$ & 300\\
   $x\,\mathtt{.min.}\,y$ & minimum, $\min(x,y)$ & 300\\
   $x\,\mathtt{::}\,y$ & euclidean dist., $\sqrt{x^2+y^2}$ & 300\\
   $x\,\mathtt{*}\,y$ & product, $x\cdot y$ & 350\\
   $x\,\mathtt{/}\,y$ & quotient (float), $x/y$ & 350\\
   $x\,\mathtt{//}\,y$ & integer division & 350\\
   $x\,\mathtt{\%}\,y$ & remainder of division & 350\\
   $x\,\mathtt{.mod.}\,y$ & remainder of division & 350\\
   $\mathtt{-}\,x$ & negation, unary minus & 400\\
   $\mathtt{+}\,x$ & unary plus & 400\\
   $x\,\mathtt{**}\,y$ & power, $x^y$ & 450\\
   $x\,\text{\tt\textasciicircum}\,y$ & power, $x^y$ & 450\\
   $x\,\mathtt{.rep.}\,y$ & repeat string ($x$) $y$ times & 450\\
   $\mathtt{+:}\,x$ & double, $2x$ & 500\\
   $\mathtt{-:}\,x$ & half, $x/2$ & 500\\
   $\mathtt{*:}\,x$ & square, $x^2$ & 1000\\
   $\mathtt{/:}\,x$ & inverse, $1/x$ & 1000\\
   $\mathtt{.abs.}\,x$ & modulus, $\vert x\vert$ & 1000\\
   $\mathtt{.acos.}\,x$ & trigonometric func., $\cos^{-1} x$ & 1000\\
   $\mathtt{.asin.}\,x$ & trigonometric func., $\sin^{-1} x$ & 1000\\
   $\mathtt{.atan.}\,x$ & trigonometric func., $\tan^{-1} x$ & 1000\\
   $\mathtt{.cos.}\,x$ & trigonometric func., $\cos x$ & 1000\\
   $\mathtt{.cosh.}\,x$ & hyperbolic func., $\cosh x$ & 1000\\
   $\mathtt{.even.}\,x$ & checks whether $x$ is even & 1000\\
   $\mathtt{.exp.}\,x$ & exponential, $e^x$ & 1000\\
   $\mathtt{.floor.}\,x$ & round $x$ towards $-\infty$ & 1000\\
   $\mathtt{.ceil.}\,x$ & round $x$ towards $+\infty$ & 1000\\
   $x\,\mathtt{.lcm.}\,y$ & least common multiple & 1000\\
   $\mathtt{.len.}\,x$ & length of $x$ (str) & 1000\\
   $\mathtt{.log.}\,x$ & natural logarithm, $\log x$ & 1000\\
   $x\,\mathtt{.log.}\,y$ & logarithm, $\log_x y$ & 1000\\
   $\mathtt{.odd.}\,x$ & checks whether $x$ is odd & 1000\\
   $\mathtt{.sign.}\,x$ & sign of $x$ & 1000\\
   $\mathtt{.sin.}\,x$ & trigonometric func., $\sin x$ & 1000\\
   $\mathtt{.sinh.}\,x$ & hyperbolic func., $\sinh x$ & 1000\\
   $\mathtt{.sqrt.}\,x$ & square root, $\sqrt{x}$ & 1000\\
   $\mathtt{.str.}\,x$ & convert $x$ to string & 1000\\
   $\mathtt{.tan.}\,x$ & trigonometric func., $\tan x$ & 1000\\
   $\mathtt{.tanh.}\,x$ & hyperbolic func., $\tanh x$ & 1000\\
   $\mathtt{`}\,x$ & interpret as symbol name & 1000\\
   $\mathtt{'}x$ & quote (no space inbetween) & 1000\\
   \end{longtable}
   \end{center}
\item[\texttt{extension} {[\texttt{!}]}\synt{name$_1$} 
   {[\texttt{!}]}\synt{name$_2$} \dots
   {[\texttt{!}]}\synt{name$_n$} {[\texttt{require=}\lit{all}\texttt{|}%
\lit{any}\texttt{|}\lit{no}]} $\to$ \synt{logical}]
   This function checks whether a set of extensions is activated.
   An exclamation mark in front of an extension name checks for absence
   rather than presence. The optional argument \texttt{require}
   defines how the checks for the single extensions should be combined
   to an end result.
\item[\texttt{golem\_path} {[\synt{arg$_1$} \ldots \synt{arg$_n$}]} $\to$
   \synt{string}]
   Returns the \golem{} installation path. The arguments are appended to
   the path using the current path seperator (Linux: \lit{/}).
\item[\texttt{include} \synt{file-name}] Includes another template file
   at this position. The \synt{file-name} is interpreted relative to the
   current template file. The class used in the included file is the same
   as in the current file. Any symbols defined at the current position
   are made visible in the included file.
\item[\texttt{indexof} \synt{needle} \synt{haystack}
   {[\texttt{delimiter=}\synt{delimiter}]}
   {[\texttt{shift=}\synt{shift}]} $\to$ \synt{integer}]
   Returns the index at which \synt{needle} appears in \synt{haystack},
   where the latter is interpreted as a list seperated by \synt{delimiter}.
   If \synt{delimiter} is not given, the comma (\lit{,}) is used as a
   delimiter. Indices start from zero or \synt{shift}, if \synt{shift} is
   present. If \synt{needle} is not found in \synt{haystack}, $-1$ is
   returned.
\item[\texttt{internal} \synt{name} $\to$ \synt{string}]
   Returns the value of an internal symbol called \synt{name}.
   The name is case insensitive. Currently, the list of internal symbols
   is
\begin{verbatim}
GENERATE_DERIVATIVES   DERIVATIVES_AT_ZERO
REGULARIZATION_DRED    REGULARIZATION_HV
GAUGE_CHECK            NUMPOLVEC
REDUCE_HELICITIES      OLP_DAEMON
\end{verbatim}
   Typically, these symbols have the value \lit{True} or \lit{False}.
\item[\texttt{max} \synt{var} \ldots $\to$ \synt{string}] The arguments
   after \synt{var} are interpreted as an iterator. The result is the
   maximum element
   of the values of \synt{var} for each iteration of the iterator.
\item[\texttt{member} \synt{needle} \synt{haystack} {[\texttt{ignore\_case}]}
{[\texttt{numeric}]} $\to$ \synt{logical}]
   This function tests for membership of the value of \synt{needle}
   in \synt{haystack}. The latter one can be a symbol denoting a list,
   a range (specified as \synt{from}\texttt{:}\synt{to}[\texttt{:}\synt{step}])
   or a list of values. If \lit{ignore\_case} is present the comparison
   is not case sensitive. If \lit{numeric} is present \synt{needle}
   is converted to a number before comparing to \synt{haystack}.
\item[\texttt{min} \synt{var} \ldots $\to$ \synt{string}] The arguments
   after \synt{var} are interpreted as an iterator. The result is the
   minimum element
   of the values of \synt{var} for each iteration of the iterator.
\item[\texttt{nl} {[\texttt{dos}]} {[\texttt{rep=}\synt{factor}]}
   $\to$ \synt{string}]
   Returns a new-line character sequence. By default, the result
   is \lit{\\n}. If \lit{dos} is given as an argument the result is
   \lit{\\r\\n} instead. The integer argument \synt{factor} specifies
   how many times the result should be repeated.
\item[\texttt{sum} \synt{var} \ldots $\to$ \synt{integer}] The arguments
   after \synt{var} are interpreted as an iterator. The result is the
   sum of the values of \synt{var} for each iteration of the iterator.
\item[\texttt{subscript} \synt{list} \synt{index}
   {[\texttt{delimiter=}\synt{delimiter}]}
   {[\texttt{shift=}\synt{shift}]} $\to$ \synt{string}]
   Selects the element at index \synt{index} in the list
   represented by \synt{list}. If \synt{delimiter} is not present
   the list is assumed to be comma-seperated. Indices are zero-based
   unless \synt{shift} is specified, in which case \synt{shift}
   denotes the index of the first element.
\item[\texttt{tab} {[\texttt{rep=}\synt{rep}]} $\to$ \synt{string}]
   Generates the given
   number (\synt{rep}) of horizontal tabulator (\lit{\\t}) characters.
\item[\texttt{time\_stamp} {[\texttt{space=}\synt{char}]}
   {[\texttt{format=}\synt{format}]} $\to$ \synt{string}]
   Returns a time stamp of the current system time. If \synt{format} is
   not given, the return format is \lit{YYYY-MM-DD}. Otherwise the given
   format is used for conversion. If \synt{space} is given the
   character \synt{space} is replaced by a \lit{ } in \synt{format} before
   the format is used. Example:
\begin{lstlisting}
File generated [% time_stamp 
           format=DD*MM*YYYY space=* %]
\end{lstlisting}
   This would produce the following output:
\begin{lstlisting}
File generated 23 01 2012
\end{lstlisting}
\item[\texttt{user\_name} $\to$ \synt{string}]
   Returns the login name of the user running \golem{}.
\item[\texttt{version\_newer} \synt{version$_1$} \synt{version$_2$}
   $\to$ \synt{logical}]
   Returns whether \synt{version$_1$} denotes a newer version than
   \synt{version$_2$}. For example $3.0>2.1.1>2.1>2.0.4$, whereas
   $2.0.0=2.0$.
\end{description}
%---------------------------------------------------------------------
\subsection{Iterators}
%---------------------------------------------------------------------
\begin{description}
\item[\texttt{banner}
   {[\texttt{width=}\synt{width}]}
   {[\texttt{prefix=}\synt{prefix}]}
   {[\texttt{suffix=}\synt{suffix}]}]
   This iterator yields the lines of the banner. Each line is surrounded
   by the characters in \synt{prefix} and \synt{suffix}, where the
   \synt{suffix} character string is aligned such that the banner
   appears aligned to the left and with a width of \synt{width} characters.
\item[\texttt{cuts} \synt{legs}
   {[\texttt{cut=}\texttt{cut}]}
   {[\texttt{uncut=}\texttt{uncut}]}
   {[\texttt{maxcut=}\texttt{maxcut}]}
   {[\texttt{shift=}\texttt{shift}]}
   {[\texttt{delim=}\texttt{delim}]}]
   This iterator lists all possible cuts (in the sense of a unitarity
   method) of the legs $0\dots\synt{legs}$. The number \synt{maxcut}
   (default: 4) defines the highest number of simultaneous cuts to put.
   The lists of cut and uncut propagators are returned in the symbols
   \texttt{cut} and \texttt{uncut} respectively. The symbol \synt{delim}
   (empty string by default) seperates the propagator labels. The lists
   are sorted from highest to lowest such that a zero is never a leading
   zero.
   The symbols \texttt{is\_first} and \texttt{is\_last} have their
   usual meaning.
\item[\texttt{debug\_options}] This iterator loops over all
   currently set options. The name is stored in the symbol \lit{name},
   the value in \lit{\$\_}.
\item[\texttt{each} \synt{arg$_1$}\dots \synt{arg$_n$}
  {[\texttt{var=}\synt{var}]}
   {[\texttt{first=}\synt{first}]}
   {[\texttt{last=}\synt{last}]}]
   This iterator loops over its arguments which are stored in
   the symbol \lit{\$\_} or whatever the argument \synt{var} points to.
   The arguments \synt{first} and \synt{last} define the names of the flags
   which are true if the current iteration is the first (resp. last) one.
   Their default values are \lit{is\_first} and \lit{is\_last} respectively.
\item[\texttt{elements} \synt{list}
   {[\texttt{delimiter=}\synt{delimiter}]}
   {[\texttt{shift=}\synt{shift}]}]
   Further arguments are  {[\texttt{var=}\synt{var}]}
   {[\texttt{index=}\synt{index}]}
   {[\texttt{first=}\synt{first}]}
   {[\texttt{last=}\synt{last}]}.

   This iterator loops over the elements of a list denoted by \synt{list}.
   If \synt{delimiter} is specified the elements of the list are assumed to
   be delimited by that symbol, otherwise \lit{,} is used as a delimiter.
   The elements are stored in the symbol defined by \synt{var}
   (default: \lit{\$\_}). The corresponding list index (starting from zero
   or \synt{shift}) is stored in the symbol defined by \synt{index}.
   The arguments \synt{first} and \synt{last} define the names of the flags
   which are true if the current iteration is the first (resp. last) one.
   Their default values are \lit{is\_first} and \lit{is\_last} respectively.
\item[\texttt{options} \synt{pattern} {[\texttt{ignorecase}]}]
   This iterator lists all defined symbols
   which are consistend with the pattern \synt{pattern}. A pattern has the
   form
\begin{grammar}
<pattern> ::= <name part>
   \alt <name part> '.' <pattern>

<name part> ::= <word without '.'> \alt '*'
\end{grammar}
   Additional optional arguments:
   \begin{description}
   \item[\texttt{first}] (default: \lit{is\_first}) sets the name of the
      flag indicating that this iteration is the first one.
   \item[\texttt{last}] (default: \lit{is\_last}) sets the name of the
      flag indicating that this iteration is the last one.
   \item[\texttt{var}] (default: \lit{\$\_}) sets the symbol
      denoting the value of the variable of the matched name.
   \item[\texttt{name}] (default: \lit{name}) sets the symbol
      denoting the matched name.
   \end{description}

   The following example is taken from a Makefile:
\begin{lstlisting}
LDFLAGS=[%
   @for options *.ldflags ignorecase %] \
      [% $_ %][%
   @end @for %]
\end{lstlisting}
\item[\texttt{repeat} {[\synt{from}]} \synt{to} {[\synt{step}]}
   {[\texttt{inclusive}]} {[\texttt{shift=}\synt{shift}]}
   {[\texttt{var=}\synt{var}]}]
   This iterator repeats a loop the given number of times.
   The loop counter \synt{var} (default: \lit{\$\_}) is initialized
   to \synt{from} (default: 0). After each iteration the loop counter
   is increased by \synt{step} (default: 1). The loop is repeated
   as long as the counter is less than \synt{to}. If \texttt{inclusive}
   is pressend the loop is repeated as long as the counter is less or equal
   than \synt{to}. The symbols \lit{is\_first} and \lit{is\_last} are
   defined with their usual meaning.
\item[\texttt{tens\_rec\_info} \synt{rank} {[\texttt{dim=}\synt{dim}]}
   {[\texttt{shift\_args=}\synt{shift}]}]
   Further optional arguments are \texttt{coeff=}\synt{coeff},
   \texttt{args=}\synt{args},
   \texttt{symmetry=}\synt{symmetry},
   \texttt{sign=}\synt{sign},
   \texttt{k=}\synt{k},
   \texttt{i=}\synt{i}; they all have their name as default value.

   This iterator loops over all coefficients needed for tensorial
   reconstruction of rank \synt{rank}.

   Example:
\begin{lstlisting}
[%
@for tens_rec_info rk shift_args=1 %]
coeffs%c[% coeff %][%
   @select coeff @case 0 %][%
   @else %]([%k%],[%i%])[%
   @end @select %] = ([%sign%]) * derivative([%
      args %]) / [% symmetry %].d0[%
@end @for %]
\end{lstlisting}
\end{description}
%---------------------------------------------------------------------
\subsection{Environments}
%---------------------------------------------------------------------
\begin{description}
\item[\texttt{env}
   \synt{key$_1$}\texttt{=}\synt{value$_1$}\dots
   \synt{key$_n$}\texttt{=}\synt{value$_n$}]
   Defines an environment in which the assignments of the arguments
   are defined as symbols.
\item[\texttt{eval} \synt{expression} \ldots \texttt{result=}\synt{name}]
   Defines an environment by assigning the result of the evaluation of
   \synt{expression} to \synt{name}. The details about the expression
   syntax can be found in the description of the \emph{function} \texttt{eval}.
\item[\texttt{modules} \synt{file-name}
   {[\texttt{path=}\synt{path}]}
   {[\texttt{replace=}\synt{pattern} \texttt{by=}\synt{replacement}]}]
   Defines symbols by reading in a file of `chunks'. The file needs to
   have an unindented line of the form:
\begin{verbatim}
boundary=...
\end{verbatim}
   Whatever comes after the \lit{=} sign defines the boundary between
   different chunks. The following example defines an error message
   in different languages:
\begin{verbatim}
You can put anything you like before the boundary line.

boundary=XXXXX

Now follows the first chunk

--XXXXX name=error.en
This is the error message.
--XXXXX name=error.de
Das ist eine Fehlermeldung.
--XXXXX--
\end{verbatim}
   Assuming the file is called \lit{error.txt},
   in the template file one could use:
\begin{lstlisting}
print*, [%
@with modules error.txt %][%
   @select language
   @case de %]"[%error.de%]"[%
   @else %]"[%error.en%]"[%
   @end @select %][%
@end @with %]
\end{lstlisting}
   The argument \synt{path} may be \lit{process} (denoting the process path),
   \lit{templates} (denoting the template path),
   \lit{golem} (denoting the \golem{} installation path) or
   a relative or absolute path name. The arguments \synt{pattern} and
   \synt{replacement} can be used to replace part of the file name
   depending on the value of a currently defined symbol, e.g.
\begin{lstlisting}
[% modules errorXYZ.txt
      replace=XYZ by=helicity %]
\end{lstlisting}
\item[\texttt{os} {[\texttt{prefix=}\synt{prefix}]}]
   Provides an environment containing all environment variables
   as symbols. If \synt{prefix} is supplied as an argument all
   variable names are prefixed with \synt{prefix}.
\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{\texttt{Kinematics}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The class \texttt{Kinematics} is derived from the base class.

%---------------------------------------------------------------------
\subsection{Functions}
%---------------------------------------------------------------------
\begin{description}
\item[\texttt{crossed\_symmetry\_factor} $\to$ \synt{integer}]
   Returns the symmetry factor arising from identical final state
   particles computed for the current crossing.

\attention This function must be nested inside a loop over all
   \texttt{crossings}.
\item[\texttt{in\_helicities} $\to$ \synt{integer}]
   This is the reciprocal of the helicity average factor.
\item[\texttt{isqcd} {[\synt{name$_1$}]} \dots
 {[\synt{name$_n$}]} $\to$ \synt{logical}] This function determines
   if the correction type is QCD. The arguments are the same as in
   \texttt{loqcd}.
\item[\texttt{loqcd} {[\synt{name$_1$}]} \dots
 {[\synt{name$_n$}]} $\to$ \synt{integer}] This function returns the
   power of the strong coupling $g_s$ in the leading order amplitude.
   The arguments \synt{name$_1$}, \dots, \synt{name$_n$} are a list of
   names for the leading order coupling which is used instead of the
   standard choice \texttt{qcd}, \texttt{gg}, \texttt{gs}.
\item[\texttt{num\_in} $\to$ \synt{integer}]
   The number of initial state particles.
\item[\texttt{num\_out} $\to$ \synt{integer}]
   The number of final state particles.
\item[\texttt{num\_legs} $\to$ \synt{integer}]
   The number of external particles.
\item[\texttt{num\_helicities} $\to$ \synt{integer}]
   The number of helicity amplitudes.
\item[\texttt{symmetry\_factor} $\to$ \synt{integer}]
   The symmetry factor arising from
   identical particles in the final state.
\item[\texttt{tree\_sign} \synt{diagram} $\to$ \synt{integer}]
   Returns the sign of the
   tree diagram with the number \synt{diagram} computed from the
   Majorana fermion permutation.
\end{description}
%---------------------------------------------------------------------
\subsection{Iterators}
%---------------------------------------------------------------------
\begin{description}
\item[\texttt{crossings}
    {[\texttt{index=}\synt{index}]} {[\texttt{var=}\synt{var}]}]
   This iterator loops over all crossings requested
   by the user. \texttt{is\_first} and \texttt{is\_last} have their usual
   meaning. The symbol \synt{index} runs a zero based counter along with
   the names of the crossings which are stored in \synt{var}
   (default: \lit{\$\_}).
\item[\texttt{crossed\_color}
    {[\texttt{initial}]} {[\texttt{final}]}
    {[\texttt{index=}\synt{index}]} {[\texttt{var=}\synt{var}]}]
   Only available in files which are
   generated inside an XML-loop over crossing.
   Iterates over the color mapping for this crossing defined by
   \synt{index} $\to$ \synt{var} (default: \lit{\$\_}).
\item[\texttt{crossed\_helicities}
    {[\texttt{initial}]} {[\texttt{final}]}
    {[\texttt{index=}\synt{index}]} {[\texttt{var=}\synt{var}]}]
    Same as \texttt{crossed\_color}
    but for helicities instead of color.
\item[\texttt{crossing}
    {[\texttt{sign=}\synt{sign}]}
    {[\texttt{index=}\synt{index}]} {[\texttt{var=}\synt{var}]}]
    This iterator defines the permutation of the legs needed to obtain
    the crossing from the original amplitude. The symbol \synt{sign}
    denotes a number $\pm1$. A value of $-1$ indicates that the corresponding
    vector has to be negated because a final state momentum is crossed into
    initial state or vice versa.
\item[\texttt{pairs}
   {[\texttt{ordered}]} {[\texttt{distinct}]} \ldots] Iterator over
   pairs of external particles. This iterator has the same filters and
   names as \texttt{particles} but with either a \lit{1} or \lit{2} attached
   to the name as a suffix. Furthermore, the argument \texttt{ordered}
   indicates that only ordered pairs are included in the iteration
   (including the case of the first and the second particle having the same
   index). The presence of the argument \texttt{distinct} excludes the
   cases where the first and second particle are the same.
\item[\texttt{particles}
   {[\synt{filter$_1$}]}\dots {[\synt{filter$_n$}]}
   {[\synt{name$_1$}\texttt{=}\synt{new-name$_1$}]}\dots]
   This iterator loops over the external particles in this process.
   The user can apply the following filters to restrict the particles
   by spin, color, mass and direction:
   \begin{description}\footnotesize
   \item[\textsc{Selection by Direction}]
   \item[\texttt{initial}] initial state particles
   \item[\texttt{final}] final state particles
   \item[\textsc{Selection by Mass}]
   \item[\texttt{massive}] massive particles
   \item[\texttt{lightlike}] massless (light-like) particles
   \item[\textsc{Selection by Color}]
   \item[\texttt{white}] uncolored particles
   \item[\texttt{colored}] colored particles
   \item[\texttt{fundamental}] particles in the fundamental or
          anti-fundamental representation
   \item[\texttt{quarks}] particles in the fundamental representation
   \item[\texttt{anti-quarks}] particles in the
          anti-fundamental representation
   \item[\texttt{adjoint|gluons}] particles in the adjoint representation
   \item[\textsc{Selection by Spin}]
   \item[\texttt{scalar}] spin-$0$ particles
   \item[\texttt{spinor}] spin-$1/2$ particles
   \item[\texttt{vector}] spin-$1$ particles
   \item[\texttt{vectorspinor}] spin-$3/2$ particles
   \item[\texttt{tensor}] spin-$2$ particles
   \item[\texttt{boson}] spin $0$, $1$ or $2$ particles
   \item[\texttt{fermion}] spin $1/2$ or $3/2$ particles
   \end{description}
The iterator defines the following names:
   \begin{description}\footnotesize
   \item[\texttt{index}] The index of this particle.
       This index runs from 1 to the number of external particles.
   \item[\texttt{out\_index}] This index is only defined for final state
       particles and runs from 1 to the number of final state particles.
   \item[\texttt{hel}] The helicity of this particle.
   \item[\texttt{mass}] The (symbolic) mass of this particle or zero
       if the particle is massless.
   \item[\texttt{spin}] The spin of this particle as a fraction, e.g.
      \lit{0}, \lit{1/2}, \lit{1}, \dots
   \item[\texttt{2spin}] Twice the spin of this particles as an integer
      number. This value is negative for anti-particles.
   \item[\texttt{is\_lightlike}] Flag indicating if this particle is massless.
   \item[\texttt{is\_massive}] Flag indicating if this particle is massive.
   \item[\texttt{is\_initial}] Flag indicating if this particle is an
      initial state particle.
   \item[\texttt{is\_final}] Flag indicating if this particle is an
      final state particle.
   \item[\texttt{color}] The color representation of this particle
      as an integer number such as $1$, $\pm3$, $8$.
   \item[\texttt{latex}] The \LaTeX{} name of the current particle.
   \item[\texttt{is\_first}] Flag indicating if this is the first
      iteration (not necessarily the first particle in the process).
   \item[\texttt{is\_last}] Flag indicating if this is the last
      iteration (not necessarily the last particle in the process).
   \item[\texttt{reference}] (where applicable) the index of the reference
      vector for this particle. This number is positive for light-like
      reference vectors and is minus the index of the reference vector
      if the latter is massive.
   \end{description}

   Please, note that all names can be prefixed by setting the argument
   \texttt{prefix}.
\item[\texttt{quark\_loop\_masses}] This iterator enumerates all
   quark masses present in closed quark loops. The arguments
   \texttt{prefix}, \texttt{var}, \texttt{first} and \texttt{last}
   are used with their usual meaning.
\item[\texttt{mandelstam}
   {[\texttt{zero|non-zero}][\texttt{mass|non-mass}]}]
   This iterator runs over all independent Mandelstam variables defined
   for this process.

   This iterator takes the following additional optional options:
   \smallskip

\begin{tabular}{l|l|p{12em}}
\textbf{Name} & \textbf{Default} & \textbf{Description} \\
\hline
   \texttt{first} & \lit{is\_first} & name of a symbol
      indicating if this is the first iteration.\\
   \texttt{last} & \lit{is\_last} & name of a symbol
      indicating if this is the last iteration.\\
   \texttt{zero} & \lit{is\_zero} & name of a symbol 
      indicating if this Mandelstam variable is zero.\\
   \texttt{non-zero} & \lit{is\_non-zero} & name of a symbol 
      indicating if this Mandelstam variable is non-zero.\\
   \texttt{mass} & \lit{is\_mass} & name of a symbol 
      indicating if this Mandelstam variable is a mass, i.e. the square of an external momentum.\\
   \texttt{non-mass} & \lit{is\_non-mass} & name of a symbol 
      indicating if this Mandelstam variable is not a mass\\
   \texttt{symbol} & \lit{symbol} & name of a symbol
      holding the name of the Mandelstam variable derived
      from the indices of the vectors and the format
      defined by \texttt{sym\_prefix}, \texttt{sym\_suffix} and
      \texttt{sym\_infix}.\\
   \texttt{index} & \lit{index} & counter of all Mandelstam variables
      selected in this loop.\\
   \texttt{global\_index} & \lit{global\_index} &
      counter of all Mandelstam variables.\\
   \hline
   \texttt{sym\_prefix} & \lit{es} & \multirow{3}{*}{
\begin{minipage}{\linewidth}
  The elements to build up the name of the Mandelstam variable. See below.
\end{minipage}}\\
   \texttt{sym\_suffix} & \lit{} \\
   \texttt{sym\_infix} & \lit{}
\end{tabular}
\smallskip

The variable $s_{123}$ by default is translated to \texttt{es123}. With
\texttt{sym\_prefix=}\lit{s(}, \texttt{sym\_suffix}=\lit{)} and
\texttt{sym\_infix=}\lit{,} this would read \texttt{s(1,2,3)}.
\item[\texttt{mandelstam\_expression}]
   This iterator is quite complex. In this exceptional case the reader
   is referred to the source code.
\item[\texttt{latex\_color\_base}
   {[\texttt{var=}\synt{var}]}
   {[\texttt{expr=}\synt{expression}]}]
   This iterator runs over all color basis elements and returns their
   definition in \LaTeX{} format. \synt{var} (default: \lit{\$\_}
   defines the symbol holding
   the color index, \synt{expression} the name of the symbol holding
   the \LaTeX expression.
\item[\texttt{color\_mapping}
   {[\texttt{index=}\synt{index}]}
   {[\texttt{var=}\synt{var}]}] Iterator over all color basis elements
   and the permutation induced by the mapping between two helicities.
   The additional parameters \lit{first}, \lit{last} and \lit{prefix}
   have their usual meaning. The permutation between the color basis
   elements is defined by \synt{index} $\to$ \synt{var}, where \synt{var}
   has \lit{\$\_} as default value.
\item[\texttt{helicity\_mapping}
  {[\texttt{index=}\synt{index}]}
  {[\texttt{var=}\synt{var}]}
  {[\texttt{sign=}\synt{sign}]}
  {[\texttt{parity=}\synt{parity}]}
  {[\texttt{shift=}\synt{shift}]}]
   For the current helicity, this iterator
   runs over the indices of all external particles returning the required
   permutation, the sign and a flag indicating if parity needs to be applied
   to this vector. The arguments \lit{first}, \lit{last} and \lit{prefix}
   have their usual meaning. The arguments \synt{sign}, \synt{parity},
   and \synt{index} have their names as default values and
   define the variable names filled by the iterator. The default of \synt{var}
   is \lit{\$\_}.
   The symbol \synt{index} contains the index of the particle at
   which the momentum of particle \synt{var} should appear in the
   argument list of the actually called amplitude (which has the helicity
   label \lit{map.index}). \synt{sign} is $-1$ if a final state particle is
   assigned at an initial state position or vice versa; \synt{parity} being
   true indicates that a parity transformation should be applied to this
   vector.
\item[\texttt{helicities} {[\texttt{generated}]}]
   If \lit{generated} is given in the arguments, only helicities
   are included for which code has been generated.

   This iterator takes the following additional optional options:
   \smallskip

\begin{tabular}{l|l|p{16em}}
\textbf{Name} & \textbf{Default} & \textbf{Description} \\
\hline
\texttt{symbol\_plus} &  \lit{+} & defines which
      symbol is used in the output to indicate `+' helicity.\\
\texttt{symbol\_plus2} &  \lit{p} & defines which
      symbol is used in the output to indicate `++' helicity.\\
\texttt{symbol\_minus} &  \lit{-} & defines which
      symbol is used in the output to indicate `-' helicity.\\
\texttt{symbol\_minus2} &  \lit{m} & defines which
      symbol is used in the output to indicate `-{}-' helicity.\\
\texttt{symbol\_zero} &  \lit{0} & defines which
      symbol is used in the output to indicate zero helicity.\\
\texttt{base} &  \lit{0} & the number starting
      from which helicities are labeled.\\
\texttt{prefix} & \lit{} & common prefix to put in front of all symbols.\\
\texttt{var} & \lit{helicity} & symbol representing the helicity label.\\
\texttt{first} & \lit{is\_first} & symbol flagging if this is the first
      iteration.\\
\texttt{first} & \lit{is\_first} & symbol flagging if this is the last
      iteration.\\
\texttt{is\_generated} & \lit{generated} & symbol flagging if code for this
      helicity needs to be generated.\\
\texttt{map.index} & \lit{map.index} & symbol representing the helicity label
      this helicity is mapped to.\\
\texttt{where} & --- & filter restricting the helicities.

      Currently, this is only used in the calculation of spin correlated
      tree-level matrix elements in combination with
      \texttt{modified\_helicity}.
\end{tabular}

\item[\texttt{modified\_helicity} \texttt{modify=}\synt{index}
       \texttt{to=}\synt{new}] Returns the helicity index of the helicity
   where the helicity of particle \synt{index} is modified to
   \synt{new}. If no such helicity is defined the iterator has no
   iterations. Further optional arguments are \lit{symbol\_plus},
   \lit{symbol\_minus}, \lit{symbol\_plus2}, \lit{symbol\_minus2},
   \lit{symbol\_zero}, \lit{base}, \lit{prefix} and \lit{var} with the
   same meaning as in the iterator \texttt{helicities}.

   Currently, this is only used in the calculation of spin correlated
   tree-level matrix elements.
\item[\texttt{instructions}
   {[\texttt{opcode=}\synt{opcode}]}
   {[\texttt{index1=}\synt{index$_1$}]}
   {[\texttt{mass1=}\synt{mass$_1$}]}
   {[\texttt{index2=}\synt{index$_2$}]}
   {[\texttt{mass2=}\synt{mass$_2$}]}]
   This iterator generates a list of
   instructions to initialize the splitting of massive external momenta.
   The symbol \synt{opcode} (default: \lit{opcode}) can be either one or two:
   \begin{enumerate}
   \item Particle \synt{index$_1$} is massive, particle \synt{index$_2$}
       is lightlike.
   \item Both particles \synt{index$_1$} and \synt{index$_2$} are massive.
   \end{enumerate}
   The arguments \synt{opcode}, \synt{index$_i$} and \synt{mass$_i$}
   have their names as default values.

   The symbols \texttt{is\_first} and \texttt{is\_last} have their
   usual meaning.
\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{\texttt{Integrals}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The class \lit{Integrals} is derived from \lit{Kinematics}. It provides
additional information about each loop diagram.

%---------------------------------------------------------------------
\subsection{Functions}
%---------------------------------------------------------------------
\begin{description}
\item[\texttt{latex\_parameter} \synt{expr} $\to$ \synt{string}]
   Converts the product expression \synt{expr} into \LaTeX{}
   format.
\item[\texttt{complex\_mass\_needed} \texttt{group=}\synt{index}
   $\to$ \synt{logical}]
    This function indicates whether the integrals of a certain group
    require complex masses.
\item[\texttt{lo\_flags} {[\texttt{diagram=}\synt{diagram}]} $\to$
   \synt{list}]
    Returns a set of group names defined by the Python filters in the
    input file.
    If \synt{diagram} is specified the list contains all group names
    to which this diagram belongs. If \synt{diagram} is not specified
    this function returns a list of \emph{all} filter groups.
\item[\texttt{loopsize}
   \texttt{group|diagram=}\synt{index} $\to$ \synt{integer}]
    The loop size of either the diagram with the index \synt{index} or
    the maximum loop size appearing in the group with the index \synt{index}.
\item[\texttt{maxloopsize} $\to$ \synt{integer}]
    The maximum loop size appearing in the one-loop diagrams of this
    process.
\item[\texttt{nlo\_flags} {[\texttt{diagram|group=}\synt{index}]} $\to$
   \synt{list}]
    Returns a set of group names defined by the Python filters in the
    input file.
    If \synt{index} is specified the list contains all group names
    to which this diagram or group (w.r.t. the integral) belongs.
    If \synt{index} is not specified
    this function returns a list of \emph{all} filter groups.
\item[\texttt{use\_flags\_0}] flag indicating whether filter groups
    are used at tree level.
\item[\texttt{use\_flags\_1}] flag indicating whether filter groups
    are used at one-loop level.
\item[\texttt{min\_diagram\_0}] the minimum diagram index at tree level.
    Also: \texttt{max\_diagram\_0}.
\item[\texttt{min\_diagram\_1}] the minimum diagram index at one-loop level.
    Also: \texttt{max\_diagram\_1}.
\end{description}
%---------------------------------------------------------------------
\subsection{Iterators}
%---------------------------------------------------------------------
\begin{description}

\item[\texttt{all_masses}
      {[\texttt{prefix=}\synt{prefix}]}] 
      This iterator enumerates the set of all external particle and 
      propagator masses present in all diagrams. 
      The argument \synt{prefix} (default: \lit{}) is prepended to 
      the names of the masses.
      The following symbols are defined inside the loop:
   \begin{description}\footnotesize
   \item[\texttt{is\_first}] Flag indicating if this is the first iteration of this loop.
   \item[\texttt{is\_last}] Flag indicating if this is the last iteration of this loop.
   \end{description}
\item[\texttt{diagrams}
      {[\texttt{group=}\synt{group}]}
      {[\texttt{loopsize=}\synt{loopsize}]}
      {[\texttt{idxshift=}\synt{index-shift}]}
      {[\texttt{unpinched=}\synt{set}]}
  ] 
      Further arguments are:
   \begin{description}\footnotesize
   \item[\texttt{invert}] (default: False) If \synt{set} is
      provided by default this loop returns all diagrams which for the
      given cut are non-zero. If \texttt{invert} is true only
      diagrams which are zero are returned.
   \end{description}
      The following symbols are defined inside the loop:
   \begin{description}\footnotesize
      \item[\texttt{\$\_}] the diagram index assigned by QGraf.
      \item[\texttt{is\_first}] indicates if this is the first
         iteration of this loop.
      \item[\texttt{is\_last}] indicates if this is the last
         iteration of this loop.
      \item[\texttt{index}] a continuous index over all diagrams in
         this loop.
      \item[\texttt{pinches}] the pinched propagators with respect
         to the propagators of this group.
      \item[\texttt{shift}] the shift vector used in this loop diagram
      \item[\texttt{sign}] the sign introduced if the order of the loop
         propagators is reversed ($Q\to-Q$).
      \item[\texttt{rank}] the rank of this diagram.
      \item[\texttt{is\_nf}] flag indicating whether this is an $N_f$
         type diagram.
      \item[\texttt{is\_mqse}] flag indicating whether this diagram
         has a massive quark self energy insertion.
      \item[\texttt{diagram\_sign}] possibly additional sign not part
         of the expression.
      \item[\texttt{global\_index}] a continuous index of all diagrams
         in that group.
   \end{description}
\item[\texttt{groups}
   {[\texttt{loopsize=}\synt{size}]}
   {[\texttt{rank=}\synt{rank}]}
   {[\texttt{index=}\synt{index}]}
   {[\texttt{var=}\synt{var}]}]
   This iterator loops over all groups of one-loop diagrams. If
   \synt{size} is set the iterator only loops over the groups of
   a particular size. The symbol \synt{rank} contains the effective
   rank of the group, \synt{index} is an index running from zero to
   the number of groups which are in the loop, \synt{var}
   (default: \lit{\$\_}) holds the group number.
\item[\texttt{loops_generated}]
   This iterator loops over the number of loop momenta to which diagrams
   are generated. Inside the loop, the following symbols are defined:
   \begin{description}\footnotesize
   \item[\texttt{is\_first}, \texttt{is\_last}] as usual
   \item[\texttt{loop}] the number of loop momenta
   \end{description}
\item[\texttt{propagators} \texttt{group=}\synt{group}
   {[\texttt{index=}\synt{index}]}
   {[\texttt{shift=}\synt{shift}]}
   {[\texttt{prefix=}\synt{prefix}]}
   {[\texttt{suffix=}\synt{suffix}]}]
   Runs over the list of propagators of the one-loop integral of a
   given group. The arguments \synt{prefix} (default: \lit{k})
   and \synt{suffix} (default: \lit{}) are used to form the
   names of the momenta. The momentum is returned in the
   variable \texttt{momentum}. If the momentum of the propagator
   is $Q+k_1-k_3$, and further \synt{prefix}=\lit{vecs(} and
   \synt{suffix}=\lit{,:)}, the resulting value of \texttt{momentum}
   would be \lit{vecs(1,:)-vecs(3,:)}. The symbol \texttt{mass} (resp.
   \texttt{width})
   contains the mass (resp. width) of the current propagator. The symbol
   \synt{index} (default: \lit{\$\_}) contains the index of the current
   propagator (starting from \synt{shift}, default: 0).

   The optional keywords \texttt{massless} and \texttt{massive}
   restrict the loop to propagators with a non-zero (resp. zero)
   mass only.
\item[\texttt{smat} \texttt{group=}\synt{group}
   {[\texttt{upper}]} {[\texttt{lower}]} {[\texttt{diagonal}]}
   {[\texttt{nonzero}]} {[\texttt{zero}]} {[\texttt{real}]}
   {[\texttt{complex}]}]
   Iterates over the entries of the kinematical $S$-matrix.
   The key words \texttt{upper}, \texttt{lower} and \texttt{diagonal}
   denote the parts of the matrix which should be included in the loop.
   The key words \texttt{zero} and \texttt{nonzero} only include
   zero and non-zero entries of the matrix.
   Specifying \texttt{real} or \texttt{complex} filters only
   real or complex matrix entries.

   The following arguments control the output format:
   \begin{description}\footnotesize
   \item[\texttt{prefix}] (default: \lit{s})
      defines the format of a Mandelstam variable.
   \item[\texttt{suffix}] (default: \lit{})
      defines the format of a Mandelstam variable.
   \item[\texttt{infix}] (default: \lit{})
      defines the format of a Mandelstam variable.
   \item[\texttt{powfmt}] (default: \lit{\%s**\%d})
      defines how an integer power is translated.
   \item[\texttt{prodfmt}] (default: \lit{\%s*\%s})
      defines how a product is translated.
   \end{description}

   Inside the loop the following symbols are defined:
   \begin{description}\footnotesize
   \item[\texttt{is\_first}] flag indicating if this iteration
       is the first one.
   \item[\texttt{is\_last}] flag indicating if this iteration
       is the last one.
   \item[\texttt{rowindex}] current row index (based on \texttt{shift}).
   \item[\texttt{colindex}] current column index (based on \texttt{shift}).
   \item[\texttt{eol}] set to true if the end of a row is reached.
   \item[\texttt{bol}] set to true if the beginning of a row is reached.
   \item[\texttt{re.is\_zero}] indicates if the real part of the entry
       is zero.
   \item[\texttt{im.is\_zero}] indicates if the imaginary part of the entry
       is zero.
   \item[\texttt{is\_zero}] indicates if the entry is zero.
   \item[\texttt{re}] real part of the entry, represented as
       a list of terms (seperated by \lit{;}), each term being written
       as a numerical coefficient and a product of symbols. The coefficient
       and the remainder are seperated by a colon (\lit{:}).
   \item[\texttt{im}] imaginary part of the entry; the data format is
       the same as for the real part.
\item[\texttt{loop\_flow} \synt{diagram}] defines the fermion flow
       of a loop diagram. This is needed for Majorana fermions.
   \end{description}
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{\texttt{Model}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%---------------------------------------------------------------------
\subsection{Functions}
%---------------------------------------------------------------------
\begin{description}
\item[\texttt{count}
   {[\texttt{R}]}
   {[\texttt{RP}]}
   {[\texttt{C}]}
   {[\texttt{CP}]}
] Counts how many parameters are of the given type:
   \begin{description}\small
   \item[\texttt{R}] real variable
   \item[\texttt{RP}] real constant (parameter)
   \item[\texttt{C}] complex variable
   \item[\texttt{CP}] complex constant (parameter)
   \end{description}
\item[\texttt{has\_slha\_locations}] Returns whether this model file
   defines an interface to the SLHA standard.
\end{description}
%---------------------------------------------------------------------
\subsection{Iterators}
%---------------------------------------------------------------------
\begin{description}
\item[\texttt{comment\_chars} {[\texttt{base=}\synt{base}]}
]
   This iterator loops over all characters which initiate a
   comment in a parameter file (like \texttt{param.dat} in the default
   test program). Currently, these are \lit{!}, \lit{;} and \lit{\#}.

   The variable \texttt{index} runs starting from \synt{base} (default: 1)
   providing a unique sequential index with each character.
   Furthermore, inside the
   loop the user has access to the following symbols:
   \begin{description}\small
   \item[\texttt{\$\_}] the actual character
   \item[\texttt{hex}] hexadecimal ASCII value of the character
   \item[\texttt{ord}] decimal ASCII value of the character
   \item[\texttt{unihex}] four digit hexadecimal unicode value
   \end{description}
   The symbols \texttt{is\_first} and \texttt{is\_last} are defined with
   their usual meaning.
\item[\texttt{functions}
   {[\texttt{base=}\synt{base}]}
   {[\texttt{R}]}
   {[\texttt{C}]}
] This iterator provides a list of all derived
   symbols of the model files, i.e. all model parameters which are not
   input parameters but computed depending on other model parameters.
   If \lit{R} or \lit{C} are given as parameter, the iterator loops only
   over real (resp. complex) functions.

   The variable \texttt{index} runs starting from \synt{base} (default: 1)
   providing a unique sequential index with each function.
   Furthermore, inside the
   loop the user has access to the following symbols:
   \begin{description}\small
   \item[\texttt{\$\_}] the function name
   \item[\texttt{type}] the type of the function
      being either \lit{R} or \lit{C} for real (resp. complex)
      functions.
   \end{description}
   The symbols \texttt{is\_first} and \texttt{is\_last} are defined with
   their usual meaning.
\item[\texttt{parameters}
   {[\texttt{base=}\synt{base}]}
   {[\texttt{R}]}
   {[\texttt{RP}]}
   {[\texttt{C}]}
   {[\texttt{CP}]}
] This iterator provides a list of all input (i.e. non-derived)
   parameters of the model files.
   If one or more of the following are given as parameter,
   the iterator loops only over a subset of paramters:
   \begin{description}\small
   \item[\texttt{R}] real variables
   \item[\texttt{RP}] real constants
   \item[\texttt{C}] complex variables
   \item[\texttt{CP}] complex constants
   \end{description}
   The variable \texttt{index} runs starting from \synt{base} (default: 1)
   providing a unique sequential index with each function.
   Furthermore, inside the
   loop the user has access to the following symbols:
   \begin{description}\small
   \item[\texttt{\$\_}] the parameter name
   \item[\texttt{type}] the type of the parameter
      being either \lit{R}, \lit{RP}, \lit{C} or \lit{CP}
   \item[\texttt{real}] the real part of the initialization value
   \item[\texttt{imag}] the imaginary part of the initialization value
   \item[\texttt{alignment}] a character string consisting of blank characters
      only. The length is such that \lstinline{[% alignment %][% $_ %]}
      produces all parameters nicely aligned. Therefore the length of
      this string is the length of the longest parameter name minus
      the length of this parameter name.
   \end{description}
   The symbols \texttt{is\_first} and \texttt{is\_last} are defined with
   their usual meaning.
\item[\texttt{slha\_blocks}
   {[\texttt{shift=}\synt{shift}]}
   {[\texttt{dimension=}\synt{dim: 1,2}]}
   {[\texttt{reversed}]}
   {[\texttt{upper|lower}]}
] This iterator loops over all SLHA blocks defined in the model file.
  If \synt{dim: 1,2} is present only blocks of the given dimension
  are taken into account. A variable \texttt{index} starting from
  \synt{shift} (default: 0) runs along with the blocks.
  If \texttt{reversed} is in the list of arguments, the list is traversed
  in reverse order. If \texttt{upper} (resp. \texttt{lower}) is in the
  list of arguments the name is converted accordingly. The block name
  is returned in the variable \lit{\$\_}, and \texttt{is\_first}
  and \texttt{is\_last} have their usual meaning.
\item[\texttt{slha\_entries}
   {[\texttt{upper|lower}]}
] There are two cases to distinguish: if the SLHA block is of dimension 1
  this iterator loops over all SLHA locations in this block.
  The variable \texttt{index} refers to the index within the block
  and \lit{\$\_} contains the parameter name as defined by the model file.

  In the case of a two-dimensional SLHA block this loop needs to be
  nested. The index of the outer loop refers to the first index,
  the index of the inner loop refers to the second index.
  \attention{} The symbol \lit{\$\_} has no meaning in the outer loop.
  Only in the inner loop it points to the parameter name.

  Example:
\begin{lstlisting}
[%
@for slha_blocks dimension=1 %]
Block [% $_ %][%
   @for slha_locations %]
  [% index %]  ... # variable [% $_ %][%
   @end @for %][%
@end @for %][%  
@for slha_blocks dimension=2 %]
Block [% $_ %][%
   @for slha_locations index=i1 %]
      @for slha_locations index=i2 %]
  [%i1%] [%i2%]  ... # variable: [%$_%][%
      @end @for %][%
   @end @for %][%
@end @for %]
\end{lstlisting}

  This would produce something like
\begin{lstlisting}
Block MASS
  1 ... # variable mdlMD
  2 ... # variable mdlMU
Block NMIX
  1 1 ... # variable mdlR11
  1 3 ... # variable mdlR13
  3 3 ... # variable mdlR33
\end{lstlisting}
\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{\texttt{Multi}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This template class is derived from the base class. It only
has one function.
\begin{description}
\item[\texttt{include} \synt{file-name} {[\texttt{class=}\synt{class}]}]
   Includes the given file using the class \synt{class}.
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{\texttt{LightCone}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This class is deprecated and should not be used anymore.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{\texttt{Verbatim}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This class is not implemented in terms of a Python class. There is
no markup defined for this class. The input file is copied in
verbatim to the output file. Even the character sequences
\lit{[\%} etc. are copied as they are.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{\texttt{OLP}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%---------------------------------------------------------------------
\subsection{Functions}
%---------------------------------------------------------------------
\begin{description}
\item[\texttt{olp.irregularisation}] Copies the value of
   \texttt{IRregularisation} from the contract file.
\item[\texttt{olp.irsubtractionmethod}] Copies the value of
   \texttt{IRsubtractionMethod} from the contract file.
\item[\texttt{olp.include\_color\_average}] Depending on the value of
   \texttt{MatrixElementSquareType} in the order file this symbol
   is set to true if the color average factor is to be included.
\item[\texttt{olp.include\_helicity\_average}] Depending on the value of
   \texttt{MatrixElementSquareType} in the order file this symbol
   is set to true if the spin average factor is to be included.
\item[\texttt{olp.no\_tree\_level}] Depending on the value of
   \texttt{MatrixElementSquareType} in the order file this symbol
   is set to true if no tree level amplitude should be generated and
   therefore the NLO is the square of the virtual (rather than the interference
   between tree level and virtual part).
\item[\texttt{olp.massiveparticlescheme}] Copies the value of
   \texttt{MassiveParticleScheme} from the contract file.
\item[\texttt{olp.operationmode}] Copies the value of
   \texttt{OperationMode} from the contract file.
\item[\texttt{olp.subdivide}] Copies the value of
   \texttt{SubdivideSubprocess} from the contract file.
\item[\texttt{olp.alphaspower}] Copies the value of
   \texttt{AlphasPower} from the contract file.
\item[\texttt{olp.alphapower}] Copies the value of
   \texttt{AlphaPower} from the contract file.
\item[\texttt{olp.ufomodel}] Copies the value of
   \texttt{UFOModel} from the contract file.
\item[\texttt{olp.parameters}] Copies the value of
   \texttt{Parameters} from the contract file.
\end{description}
%---------------------------------------------------------------------
\subsection{Iterators}
%---------------------------------------------------------------------
\begin{description}
\item[\texttt{subprocesses}] This iterator loops over all subprocesses
   generated for this process. The variables defined inside the loop
   are as follows:
   \begin{description}\small
   \item[\texttt{is\_first}] is set to true during the first iteration
      of the loop
   \item[\texttt{is\_last}] is set to true during the last iteration
      of the loop
   \item[\texttt{id}] the global indes assigned to this subprocess
   \item[\texttt{index}] an index counting the subprocesses
   \item[\texttt{path}] the path pointing to the generated code
   \item[\texttt{\$\_}] the generated prefix for this subprocess
   \item[\texttt{num\_legs}] number of external particles for this subprocess
   \item[\texttt{num\_helicities}] number of helicities in this subprocess
   \end{description}
\item[\texttt{generated\_helicities}] loops over all \emph{generated}
   helicity amplitudes of a subprocess. The symbol \lit{\$\_} contains
   the (global) helicity label, \texttt{index} contains a continuous index.
   The symbols \texttt{is\_first} and \texttt{is\_last} are defined with their
   usual meanings.
\item[\texttt{crossings}
   {[\texttt{include-self}]} ]
   This iterator must be enclosed in a loop over all subprocesses.
   This iterator runs over all crossings of the current subprocess.
   The uncrossed subprocess is only included if \texttt{include-self}
   is part of the arguments. Inside the loop the following
   variables are define:
   \begin{description}\small
   \item[\texttt{is\_first}] is set to true during the first iteration
      of the loop
   \item[\texttt{is\_last}] is set to true during the last iteration
      of the loop
   \item[\texttt{index}] an index counting the crossings
   \item[\texttt{id}] the global indes assigned to this crossing
   \item[\texttt{\$\_}] the generated prefix for this crossing
   \item[\texttt{channels}] the list of labels defined in the
      contract file. If \lit{SubdivideSubprocess} was set to true in
      the order file there is a list of labels, one per helicity amplitude.
      Otherwise there is exactly one label per subprocess or crossing.
   \end{description}
\end{description}
\end{document}
